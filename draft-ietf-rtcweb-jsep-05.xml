<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-ietf-rtcweb-jsep-04" ipr="trust200902">
  <front>
    <title abbrev="JSEP">Javascript Session Establishment Protocol</title>

    <author fullname="Justin Uberti" initials="J." surname="Uberti">
      <organization>Google</organization>

      <address>
        <postal>
          <street>747 6th Ave S</street>

          <city>Kirkland</city>

          <region>WA</region>

          <code>98033</code>

          <country>USA</country>
        </postal>

        <email>justin@uberti.name</email>
      </address>
    </author>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>fluffy@iii.ca</email>
      </address>
    </author>

    <date day="18" month="September" year="2013" />

    <area>RAI</area>

    <abstract>
      <t>This document describes the mechanisms for allowing a Javascript
      application to control the signaling plane of a multimedia session via
      the interface specified in the W3C RTCPeerConnection API, and discusses
      how this relates to existing signaling protocols.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document describes how the W3C WEBRTC RTCPeerConnection
      interface<xref target="W3C.WD-webrtc-20111027"></xref> is used to
      control the setup, management and teardown of a multimedia session.</t>

      <section title="General Design of JSEP">
        <t>The thinking behind WebRTC call setup has been to fully specify and
        control the media plane, but to leave the signaling plane up to the
        application as much as possible. The rationale is that different
        applications may prefer to use different protocols, such as the
        existing SIP or Jingle call signaling protocols, or something custom
        to the particular application, perhaps for a novel use case. In this
        approach, the key information that needs to be exchanged is the
        multimedia session description, which specifies the necessary
        transport and media configuration information necessary to establish
        the media plane.</t>

        <t>The browser environment also has its own challenges that pose
        problems for an embedded signaling state machine. One of these is that
        the user may reload the web page at any time. If the browser is fully
        in charge of the signaling state, this will result in the loss of the
        call when this state is wiped by the reload. However, if the state can
        be stored at the server, and pushed back down to the new page, the
        call can be resumed with minimal interruption.</t>

        <t>With these considerations in mind, this document describes the
        Javascript Session Establishment Protocol (JSEP) that allows for full
        control of the signaling state machine from Javascript. This mechanism
        effectively removes the browser almost completely from the core
        signaling flow; the only interface needed is a way for the application
        to pass in the local and remote session descriptions negotiated by
        whatever signaling mechanism is used, and a way to interact with the
        ICE state machine.</t>

        <t>In this document, the use of JSEP is described as if it always
        occurs between two browsers. Note though in many cases it will
        actually be between a browser and some kind of server, such as a
        gateway or MCU. This distinction is invisible to the browser; it just
        follows the instructions it is given via the API.</t>

        <t>JSEP's handling of session descriptions is simple and
        straightforward. Whenever an offer/answer exchange is needed, the
        initiating side creates an offer by calling a createOffer() API. The
        application optionally modifies that offer, and then uses it to set up
        its local config via the setLocalDescription() API. The offer is then
        sent off to the remote side over its preferred signaling mechanism
        (e.g., WebSockets); upon receipt of that offer, the remote party
        installs it using the setRemoteDescription() API.</t>

        <t>When the call is accepted, the callee uses the createAnswer() API
        to generate an appropriate answer, applies it using
        setLocalDescription(), and sends the answer back to the initiator over
        the signaling channel. When the offerer gets that answer, it installs
        it using setRemoteDescription(), and initial setup is complete. This
        process can be repeated for additional offer/answer exchanges.</t>

        <t>Regarding ICE <xref target="RFC5245"></xref>, JSEP decouples the
        ICE state machine from the overall signaling state machine, as the ICE
        state machine must remain in the browser, because only the browser has
        the necessary knowledge of candidates and other transport info.
        Performing this separation also provides additional flexibility; in
        protocols that decouple session descriptions from transport, such as
        Jingle, the transport information can be sent separately; in protocols
        that don't, such as SIP, the information can be used in the aggregated
        form. Sending transport information separately can allow for faster
        ICE and DTLS startup, since the necessary roundtrips can occur while
        waiting for the remote side to accept the session.</t>

        <t>Through its abstraction of signaling, the JSEP approach does
        require the application to be aware of the signaling process. While
        the application does not need to understand the contents of session
        descriptions to set up a call, the application must call the right
        APIs at the right times, convert the session descriptions and ICE
        information into the defined messages of its chosen signaling
        protocol, and perform the reverse conversion on the messages it
        receives from the other side.</t>

        <t>One way to mitigate this is to provide a Javascript library that
        hides this complexity from the developer; said library would implement
        a given signaling protocol along with its state machine and
        serialization code, presenting a higher level call-oriented interface
        to the application developer. For example, this library could easily
        adapt the JSEP API into the API that was proposed for the ROAP
        signaling protocol <xref
        target="I-D.jennings-rtcweb-signaling"></xref>, which would perform a
        ROAP call setup under the covers, interacting with the application
        only when it needs a signaling message to be sent. In the same
        fashion, one could also implement other popular signaling protocols,
        including SIP or Jingle. This allow JSEP to provide greater control
        for the experienced developer without forcing any additional
        complexity on the novice developer.</t>
      </section>

      <section title="Other Approaches Considered">
        <t>One approach that was considered instead of JSEP was to include a
        lightweight signaling protocol. Instead of providing session
        descriptions to the API, the API would produce and consume messages
        from this protocol. While providing a more high-level API, this put
        more control of signaling within the browser, forcing the browser to
        have to understand and handle concepts like signaling glare. In
        addition, it prevented the application from driving the state machine
        to a desired state, as is needed in the page reload case.</t>

        <t>A second approach that was considered but not chosen was to
        decouple the management of the media control objects from session
        descriptions, instead offering APIs that would control each component
        directly. This was rejected based on a feeling that requiring exposure
        of this level of complexity to the application programmer would not be
        beneficial; it would result in an API where even a simple example
        would require a significant amount of code to orchestrate all the
        needed interactions, as well as creating a large API surface that
        needed to be agreed upon and documented. In addition, these API points
        could be called in any order, resulting in a more complex set of
        interactions with the media subsystem than the JSEP approach, which
        specifies how session descriptions are to be evaluated and
        applied.</t>

        <t>One variation on JSEP that was considered was to keep the basic
        session description-oriented API, but to move the mechanism for
        generating offers and answers out of the browser. Instead of providing
        createOffer/createAnswer methods within the browser, this approach
        would instead expose a getCapabilities API which would provide the
        application with the information it needed in order to generate its
        own session descriptions. This increases the amount of work that the
        application needs to do; it needs to know how to generate session
        descriptions from capabilities, and especially how to generate the
        correct answer from an arbitrary offer and the supported capabilities.
        While this could certainly be addressed by using a library like the
        one mentioned above, it basically forces the use of said library even
        for a simple example. Providing createOffer/createAnswer avoids this
        problem, but still allows applications to generate their own
        offers/answers (to a large extent) if they choose, using the
        description generated by createOffer as an indication of the browser's
        capabilities.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>
    </section>

    <section title="Semantics and Syntax">
      <section title="Signaling Model">
        <t>JSEP does not specify a particular signaling model or state
        machine, other than the generic need to exchange SDP media
        descriptions in the fashion described by <xref
        target="RFC3264"></xref> (offer/answer) in order for both sides of the
        session to know how to conduct the session. JSEP provides mechanisms
        to create offers and answers, as well as to apply them to a session.
        However, the browser is totally decoupled from the actual mechanism by
        which these offers and answers are communicated to the remote side,
        including addressing, retransmission, forking, and glare handling.
        These issues are left entirely up to the application; the application
        has complete control over which offers and answers get handed to the
        browser, and when.</t>

        <figure anchor="fig-sigModel" title="JSEP Signaling Model">
          <artwork><![CDATA[
    +-----------+                               +-----------+ 
    |  Web App  |<--- App-Specific Signaling -->|  Web App  |
    +-----------+                               +-----------+
          ^                                            ^
          |  SDP                                       |  SDP 
          V                                            V
    +-----------+                                +-----------+ 
    |  Browser  |<----------- Media ------------>|  Browser  |
    +-----------+                                +-----------+
]]></artwork>
        </figure>
      </section>

      <section title="Session Descriptions and State Machine">
        <t>In order to establish the media plane, the user agent needs
        specific parameters to indicate what to transmit to the remote side,
        as well as how to handle the media that is received. These parameters
        are determined by the exchange of session descriptions in offers and
        answers, and there are certain details to this process that must be
        handled in the JSEP APIs.</t>

        <t>Whether a session description applies to the local side or the
        remote side affects the meaning of that description. For example, the
        list of codecs sent to a remote party indicates what the local side is
        willing to receive, which, when intersected with the set of codecs the
        remote side supports, specifies what the remote side should send.
        However, not all parameters follow this rule; for example, the SRTP
        parameters <xref target="RFC4568"></xref> sent to a remote party
        indicate what the local side will use to encrypt, and thereby what the
        remote party should expect to receive; the remote party will have to
        accept these parameters, with no option to choose a different
        value.</t>

        <t>In addition, various RFCs put different conditions on the format of
        offers versus answers. For example, a offer may propose multiple SRTP
        configurations, but an answer may only contain a single SRTP
        configuration.</t>

        <t>Lastly, while the exact media parameters are only known only after
        a offer and an answer have been exchanged, it is possible for the
        offerer to receive media after they have sent an offer and before they
        have received an answer. To properly process incoming media in this
        case, the offerer's media handler must be aware of the details of the
        offer before the answer arrives.</t>

        <t>Therefore, in order to handle session descriptions properly, the
        user agent needs: <list style="numbers">
            <t>To know if a session description pertains to the local or
            remote side.</t>

            <t>To know if a session description is an offer or an answer.</t>

            <t>To allow the offer to be specified independently of the
            answer.</t>
          </list> JSEP addresses this by adding both a setLocalDescription and
        a setRemoteDescription method and having session description objects
        contain a type field indicating the type of session description being
        supplied. This satisfies the requirements listed above for both the
        offerer, who first calls setLocalDescription(sdp [offer]) and then
        later setRemoteDescription(sdp [answer]), as well as for the answerer,
        who first calls setRemoteDescription(sdp [offer]) and then later
        setLocalDescription(sdp [answer]).</t>

        <t>JSEP also allows for an answer to be treated as provisional by the
        application. Provisional answers provide a way for an answerer to
        communicate initial session parameters back to the offerer, in order
        to allow the session to begin, while allowing a final answer to be
        specified later. This concept of a final answer is important to the
        offer/answer model; when such an answer is received, any extra
        resources allocated by the caller can be released, now that the exact
        session configuration is known. These "resources" can include things
        like extra ICE components, TURN candidates, or video decoders.
        Provisional answers, on the other hand, do no such deallocation
        results; as a result, multiple dissimilar provisional answers can be
        received and applied during call setup.</t>

        <t>In <xref target="RFC3264"></xref>, the constraint at the signaling
        level is that only one offer can be outstanding for a given session,
        but from the media stack level, a new offer can be generated at any
        point. For example, when using SIP for signaling, if one offer is
        sent, then cancelled using a SIP CANCEL, another offer can be
        generated even though no answer was received for the first offer. To
        support this, the JSEP media layer can provide an offer whenever the
        Javascript application needs one for the signaling. The answerer can
        send back zero or more provisional answers, and finally end the
        offer-answer exchange by sending a final answer. The state machine for
        this is as follows:</t>

        <t><figure anchor="fig-state-machine" title="JSEP State Machine">
            <artwork><![CDATA[
                    setRemote(OFFER)               setLocal(PRANSWER)
                        /-----\                               /-----\
                        |     |                               |     |
                        v     |                               v     |
         +---------------+    |                +---------------+    |
         |               |----/                |               |----/
         |               | setLocal(PRANSWER)  |               |
         |  Remote-Offer |------------------- >| Local-Pranswer|
         |               |                     |               |
         |               |                     |               |
         +---------------+                     +---------------+    
              ^   |                                   |
              |   | setLocal(ANSWER)                  |
setRemote(OFFER)  |                                   |
              |   V                  setLocal(ANSWER) |
         +---------------+                            |
         |               |                            |
         |               |                            |
         |    Stable     |<---------------------------+
         |               |                            |
         |               |                            |
         +---------------+          setRemote(ANSWER) |                   
              ^   |                                   |
              |   | setLocal(OFFER)                   |
setRemote(ANSWER) |                                   |
              |   V                                   |
         +---------------+                     +---------------+
         |               |                     |               |
         |               | setRemote(PRANSWER) |               |
         |  Local-Offer  |------------------- >|Remote-Pranswer|
         |               |                     |               |
         |               |----\                |               |----\
         +---------------+    |                +---------------+    |
                        ^     |                               ^     |
                        |     |                               |     |
                        \-----/                               \-----/
                    setLocal(OFFER)               setRemote(PRANSWER)
]]></artwork>
          </figure></t>

        <t>Aside from these state transitions, there is no other difference
        between the handling of provisional ("pranswer") and final ("answer")
        answers.</t>
      </section>

      <section title="Session Description Format">
        <t>In the WebRTC specification, session descriptions are formatted as
        SDP messages. While this format is not optimal for manipulation from
        Javascript, it is widely accepted, and frequently updated with new
        features. Any alternate encoding of session descriptions would have to
        keep pace with the changes to SDP, at least until the time that this
        new encoding eclipsed SDP in popularity. As a result, JSEP currently
        uses SDP as the internal representation for its session
        descriptions.</t>

        <t>However, to simplify Javascript processing, and provide for future
        flexibility, the SDP syntax is encapsulated within a
        SessionDescription object, which can be constructed from SDP, and be
        serialized out to SDP. If future specifications agree on a JSON format
        for session descriptions, we could easily enable this object to
        generate and consume that JSON.</t>

        <t>Other methods may be added to SessionDescription in the future to
        simplify handling of SessionDescriptions from Javascript. In the
        meantime, Javascript libraries can be used to perform these
        manipulations.</t>

        <t>Note that most applications should be able to treat the
        SessionDescriptions produced and consumed by these various API calls
        as opaque blobs; that is, the application will not need to read or
        change them. The W3C API will provide appropriate APIs to allow the
        application to control various session parameters, which will provide
        the necessary information to the browser about what sort of
        SessionDescription to produce.</t>
      </section>

      <section title="ICE">

        <t> The browser keeps a pool of potential ICE candidates available to
        help ensure rapid media setup. The size of this pool is fairly small and
        controlled by an API from the Javascript application. When the browser
        needs an new ICE candiate, it can start by seeing if any are available
        in the pool and if there are candidates in the pool, use them. There are
        times when there will not be enough candidates in the pool, either
        because a large number of candidates is needed, or because the pool has
        not had enough time to gather candidates. In these cases the trickle ICE
        mechanism allows a browser to create and offer or answer before without
        waiting for the time it would take to gather all the ICE candidates
        required if trickle ICE is not used.
        </t>

        <t>When a new ICE candidate is available, the ICE Agent will notify
        the application via a callback; these candidates will automatically be
        added to the local session description. When all candidates have been
        gathered, the callback will also be invoked to signal that the
        gathering process is complete.</t>

        <section title="ICE Candidate Trickling">
          <t>Candidate trickling is a technique through which a caller may
          incrementally provide candidates to the callee after the initial
          offer has been dispatched; the semantics of "Trickle ICE" are
          defined in <xref target="I-D.ivov-mmusic-trickle-ice"></xref>. This
          process allows the callee to begin acting upon the call and setting
          up the ICE (and perhaps DTLS) connections immediately, without
          having to wait for the caller to gather all possible candidates.
          This results in faster call startup in cases where gathering is not
          performed prior to initiating the call.</t>

          <t>JSEP supports optional candidate trickling by providing APIs that
          provide control and feedback on the ICE candidate gathering process.
          Applications that support candidate trickling can send the initial
          offer immediately and send individual candidates when they get the
          notified of a new candidate; applications that do not support this
          feature can simply wait for the indication that gathering is
          complete, and then create and send their offer, with all the
          candidates, at this time.</t>

          <t>Upon receipt of trickled candidates, the receiving application
          will supply them to its ICE Agent. This triggers the ICE Agent to
          start using the new remote candidates for connectivity checks.</t>

          <section title="ICE Candidate Format">
            <t>As with session descriptions, the syntax of the IceCandidate
            object provides some abstraction, but can be easily converted to
            and from the SDP candidate lines.</t>

            <t>The candidate lines are the only SDP information that is
            contained within IceCandidate, as they represent the only
            information needed that is not present in the initial offer (i.e.
            for trickle candidates). This information is carried with the same
            syntax as the "candidate-attribute" field defined for ICE. For
            example:</t>

            <figure>
              <artwork><![CDATA[
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host
]]></artwork>
            </figure>

            <t>The IceCandidate object also contains fields to indicate which
            m= line it should be associated with. The m line can be identified
            in one of two ways; either by a m-line index, or a MID. The m-line
            index is a zero-based index, referring to the Nth m-line in the
            SDP. The MID uses the "media stream identification", as defined in
            <xref target="RFC5888"></xref> , to identify the m-line. WebRTC
            implementations creating an ICE Candidate object MUST populate
            both of these fields. Implementations receiving an ICE Candidate
            object SHOULD use the MID if they implement that functionality, or
            the m-line index, if not.</t>
          </section>
        </section>
      </section>

      <section title="Interactions With Forking">
        <t>Some call signaling systems allow various types of forking where an
        SDP Offer may be provided to more than one device. For example, SIP
        <xref target="RFC3261"></xref> defines both a "Parallel Search" and
        "Sequential Search". Although these are primarily signaling level
        issues that are outside the scope of JSEP, they do have some impact on
        the configuration of the media plane which is relevant. When forking
        happens at the signaling layer, the Javascript application responsible
        for the signaling needs to make the decisions about what media should
        be sent or received at any point of time, as well as which remote
        endpoint it should communicate with; JSEP is used to make sure the
        media engine can make the RTP and media perform as required by the
        application. The basic operations that the applications can have the
        media engine do are: <list>
            <t>Start exchanging media to a given remote peer, but keep all the
            resources reserved in the offer.</t>

            <t>Start exchanging media with a given remote peer, and free any
            resources in the offer that are not being used.</t>
          </list></t>

        <section title="Sequential Forking">
          <t>Sequential forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, but only one
          active session ever exists at a time; no mixing of received media is
          performed.</t>

          <t>JSEP handles sequential forking well, allowing the application to
          easily control the policy for selecting the desired remote endpoint.
          When an answer arrives from one of the callees, the application can
          choose to apply it either as a provisional answer, leaving open the
          possibility of using a different answer in the future, or apply it
          as a final answer, ending the setup flow.</t>

          <t>In a "first-one-wins" situation, the first answer will be applied
          as a final answer, and the application will reject any subsequent
          answers. In SIP parlance, this would be ACK + BYE.</t>

          <t>In a "last-one-wins" situation, all answers would be applied as
          provisional answers, and any previous call leg will be terminated.
          At some point, the application will end the setup process, perhaps
          with a timer; at this point, the application could reapply the
          existing remote description as a final answer.</t>
        </section>

        <section title="Parallel Forking">
          <t>Parallel forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, and multiple
          simultaneous active signaling sessions can be established as a
          result. If multiple callees send media at the same time, the
          possibilities for handling this are described in Section 3.1 of
          <xref target="RFC3960"></xref>. Most SIP devices today only support
          exchanging media with a single device at a time, and do not try to
          mix multiple early media audio sources, as that could result in a
          confusing situation. For example, consider having a European
          ringback tone mixed together with the North American ringback tone -
          the resulting sound would not be like either tone, and would confuse
          the user. If the signaling application wishes to only exchange media
          with one of the remote endpoints at a time, then from a media engine
          point of view, this is exactly like the sequential forking case.</t>

          <t>In the parallel forking case where the Javascript application
          wishes to simultaneously exchange media with multiple peers, the
          flow is slightly more complex, but the Javascript application can
          follow the strategy that <xref target="RFC3960"></xref> describes
          using UPDATE. (It is worth noting that use cases where this is the
          desired behavior are very unusual.) The UPDATE approach allows the
          signaling to set up a separate media flow for each peer that it
          wishes to exchange media with. In JSEP, this offer used in the
          UPDATE would be formed by simply creating a new PeerConnection and
          making sure that the same local media streams have been added into
          this new PeerConnection. Then the new PeerConnection object would
          produce a SDP offer that could be used by the signaling to perform
          the UPDATE strategy discussed in <xref target="RFC3960"></xref>.</t>

          <t>As a result of sharing the media streams, the application will
          end up with N parallel PeerConnection sessions, each with a local
          and remote description and their own local and remote addresses. The
          media flow from these sessions can be managed by specifying SDP
          direction attributes in the descriptions, or the application can
          choose to play out the media from all sessions mixed together. Of
          course, if the application wants to only keep a single session, it
          can simply terminate the sessions that it no longer needs.</t>
        </section>
      </section>

      <section title="Session Rehydration">
        <t>In the event that the local application state is reinitialized,
        either due to a user reload of the page, or a decision within the
        application to reload itself (perhaps to update to a new version), it
        is possible to keep an existing session alive, via a process called
        "rehydration". The explicit goal of rehydration is to carry out this
        session resumption with no interaction with the remote side other than
        normal call signaling messages.</t>

        <t>With rehydration, the current signaling state is persisted
        somewhere outside of the page, perhaps on the application server, or
        in browser local storage. The page is then reloaded, the saved
        signaling state is retrieved, and a new PeerConnection object is
        created for the session. The previously obtained MediaStreams are
        re-acquired, and are given the same IDs as the original session; this
        ensures the IDs in use by the remote side continue to work. Next, a
        new offer is generated by the new PeerConnection; this offer will have
        new ICE and possibly new DTLS-SRTP certificate fingerprints (since the
        old ICE and SRTP state has been lost). Finally, this offer is used to
        re-initiate the session with the existing remote endpoint, who simply
        sees the new offer as an in-call renegotiation, and replies with an
        answer that can be supplied to setRemoteDescription. ICE processing
        proceeds as usual, and as soon as connectivity is established, the
        session will be back up and running again.</t>

        <t>[OPEN ISSUE: EKR proposed an alternative rehydration approach where
        the actual internal PeerConnection object in the browser was kept
        alive for some time after the web page was killed and provided some
        way for a new page to acquire the old PeerConnection object.]</t>
      </section>
    </section>

    <section title="Interface">
      <t>This section details the basic operations that must be present to
      implement JSEP functionality. The actual API exposed in the W3C API may
      have somewhat different syntax, but should map easily to these
      concepts.</t>

      <section title="Methods">
        <section title="createOffer">
          <t>The createOffer method generates a blob of SDP that contains a
          <xref target="RFC3264"></xref> offer with the supported
          configurations for the session, including descriptions of the local
          MediaStreams attached to this PeerConnection, the codec/RTP/RTCP
          options supported by this implementation, and any candidates that
          have been gathered by the ICE Agent. A constraints parameters may be
          supplied to provide additional control over the generated offer.
          This constraints parameter should allow for the following
          manipulations to be performed: <list style="symbols">
              <t>To indicate support for a media type even if no
              MediaStreamTracks of that type have been added to the session
              (e.g., an audio call that wants to receive video.)</t>

              <t>To trigger an ICE restart, for the purpose of reestablishing
              connectivity.</t>

              <t>For re-offer cases, to request an offer that contains the
              full set of supported capabilities, as opposed to just the
              currently negotiated parameters.</t>
            </list></t>

          <t>In the initial offer, the generated SDP will contain all desired
          functionality for the session (certain parts that are supported but
          not desired by default may be omitted); for each SDP line, the
          generation of the SDP will follow the process defined for generating
          an initial offer from the document that specifies the given SDP
          line. The exact handling of initial offer generation is detailed in
          Section 5.2.1. below.</t>

          <t>In the event createOffer is called after the session is
          established, createOffer will generate an offer to modify the
          current session based on any changes that have been made to the
          session, e.g. adding or removing MediaStreams, or requesting an ICE
          restart. For each existing stream, the generation of each SDP line
          must follow the process defined for generating an updated offer from
          the document that specifies the given SDP line. For each new stream,
          the generation of the SDP must follow the process of generating an
          initial offer, as mentioned above. If no changes have been made, or
          for SDP lines that are unaffected by the requested changes, the
          offer will only contain the parameters negotiated by the last
          offer-answer exchange. The exact handling of subsequent offer
          generation is detailed in Section 5.2.2. below.</t>

          <t>Session descriptions generated by createOffer must be immediately
          usable by setLocalDescription; if a system has limited resources
          (e.g. a finite number of decoders), createOffer should return an
          offer that reflects the current state of the system, so that
          setLocalDescription will succeed when it attempts to acquire those
          resources. Because this method may need to inspect the system state
          to determine the currently available resources, it may be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not result in candidate gathering, or cause
          media to start or stop flowing.</t>
        </section>

        <section title="createAnswer">
          <t>The createAnswer method generates a blob of SDP that contains a
          <xref target="RFC3264"></xref> SDP answer with the supported
          configuration for the session that is compatible with the parameters
          supplied in the offer. Like createOffer, the returned blob contains
          descriptions of the local MediaStreams attached to this
          PeerConnection, the codec/RTP/RTCP options negotiated for this
          session, and any candidates that have been gathered by the ICE
          Agent. A constraints parameter may be supplied to provide additional
          control over the generated answer.</t>

          <t>As an answer, the generated SDP will contain a specific
          configuration that specifies how the media plane should be
          established; for each SDP line, the generation of the SDP must
          follow the process defined for generating an answer from the
          document that specifies the given SDP line. The exact handling of
          answer generation is detailed in Section 5.3. below.</t>

          <t>Session descriptions generated by createAnswer must be
          immediately usable by setLocalDescription; like createOffer, the
          returned description should reflect the current state of the system.
          Because this method may need to inspect the system state to
          determine the currently available resources, it may need to be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not trigger candidate gathering or change
          media state.</t>
        </section>

        <section title="SessionDescriptionType">
          <t>Session description objects (RTCSessionDescription) may be of
          type "offer", "pranswer", and "answer". These types provide
          information as to how the description parameter should be parsed,
          and how the media state should be changed.</t>

          <t>"offer" indicates that a description should be parsed as an
          offer; said description may include many possible media
          configurations. A description used as an "offer" may be applied
          anytime the PeerConnection is in a stable state, or as an update to
          a previously supplied but unanswered "offer".</t>

          <t>"pranswer" indicates that a description should be parsed as an
          answer, but not a final answer, and so should not result in the
          freeing of allocated resources. It may result in the start of media
          transmission, if the answer does not specify an inactive media
          direction. A description used as a "pranswer" may be applied as a
          response to an "offer", or an update to a previously sent
          "answer".</t>

          <t>"answer" indicates that a description should be parsed as an
          answer, the offer-answer exchange should be considered complete, and
          any resources (decoders, candidates) that are no longer needed can
          be released. A description used as an "answer" may be applied as a
          response to a "offer", or an update to a previously sent
          "pranswer".</t>

          <t>The only difference between a provisional and final answer is
          that the final answer results in the freeing of any unused resources
          that were allocated as a result of the offer. As such, the
          application can use some discretion on whether an answer should be
          applied as provisional or final, and can change the type of the
          session description as needed. For example, in a serial forking
          scenario, an application may receive multiple "final" answers, one
          from each remote endpoint. The application could choose to accept
          the initial answers as provisional answers, and only apply an answer
          as final when it receives one that meets its criteria (e.g. a live
          user instead of voicemail).</t>

          <section title="Use of Provisional Answers">
            <t>Most web applications will not need to create answers using the
            "pranswer" type. The preferred handling for a web application
            would be to create and send an "inactive" answer more or less
            immediately after receiving the offer, instead of waiting for a
            human user to physically answer the call. Later, when the human
            input is received, the application can create a new "sendrecv"
            offer to update the previous offer/answer pair and start the media
            flow. This approach is preferred because it minimizes the amount
            of time that the offer-answer exchange is left open, in addition
            to avoiding media clipping by ensuring the transport is ready to
            go by the time the call is physically answered. However, some
            applications may not be able to do this, particularly ones that
            are attempting to gateway to other signaling protocols. In these
            cases, "pranswer" can still allow the application to warm up the
            transport.</t>

            <t>Consider a typical web application that will set up a data
            channel, an audio channel, and a video channel. When an endpoint
            receives an offer with these channels, it could send an answer
            accepting the data channel for two-way data, and accepting the
            audio and video tracks as inactive or receive-only. It could then
            ask the user to accept the call, acquire the local media streams,
            and send a new offer to the remote side moving the audio and video
            to be two-way media. By the time the human has accepted the call
            and sent the new offer, it is likely that the ICE and DTLS
            handshaking for all the channels will already be set up.</t>
          </section>

          <section title="Rollback">
            <t>In certain situations it may be desirable to "undo" a change
            made to setLocalDescription or setRemoteDescription. Consider a
            case where a call is ongoing, and one side wants to change some of
            the session parameters; that side generates an updated offer and
            then calls setLocalDescription. However, the remote side, either
            before or after setRemoteDescription, decides it does not want to
            accept the new parameters, and sends a reject message back to the
            offerer. Now, the offerer, and possibly the answerer as well, need
            to return to a stable state and the previous local/remote
            description. To support this, we introduce the concept of
            "rollback".</t>

            <t>A rollback returns the state machine to its previous state, and
            the local or remote description to its previous value. Any
            resources or candidates that were allocated by the new local
            description are discarded; any media that is received will be
            processed according to the previous session description.</t>

            <t>A rollback is performed by supplying a session description of
            type "rollback" to either setLocalDescription or
            setRemoteDescription, depending on which needs to be rolled back
            (i.e. if the new offer was supplied to setLocalDescription, the
            rollback should be done on setLocalDescription as well.)</t>
          </section>
        </section>

        <section title="setLocalDescription">
          <t>The setLocalDescription method instructs the PeerConnection to
          apply the supplied SDP blob as its local configuration. The type
          field indicates whether the blob should be processed as an offer,
          provisional answer, or final answer; offers and answers are checked
          differently, using the various rules that exist for each SDP
          line.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for receiving and decoding media. In order
          to successfully handle scenarios where the application wants to
          offer to change from one media format to a different, incompatible
          format, the PeerConnection must be able to simultaneously support
          use of both the old and new local descriptions (e.g. support codecs
          that exist in both descriptions) until a final answer is received,
          at which point the PeerConnection can fully adopt the new local
          description, or roll back to the old description if the remote side
          denied the change.</t>

          <t>This API indirectly controls the candidate gathering process.
          When a local description is supplied, and the number of transports
          currently in use does not match the number of transports needed by
          the local description, the PeerConnection will create transports as
          needed and begin gathering candidates for them.</t>

          <t>If setRemoteDescription was previous called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, and media are available to
          send, this will result in the starting of media transmission.</t>
        </section>

        <section title="setRemoteDescription">
          <t>The setRemoteDescription method instructs the PeerConnection to
          apply the supplied SDP blob as the desired remote configuration. As
          in setLocalDescription, the type field of the indicates how the blob
          should be processed.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for sending and encoding media.</t>

          <t>If setRemoteDescription was previously called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, and media are available to
          send, this will result in the starting of media transmission.</t>
        </section>

        <section title="localDescription">
          <t>The localDescription method returns a copy of the current local
          configuration, i.e. what was most recently passed to
          setLocalDescription, plus any local candidates that have been
          generated by the ICE Agent.</t>

          <t>TODO: Do we need to expose accessors for both the current and
          proposed local description?</t>

          <t>A null object will be returned if the local description has not
          yet been established, or if the PeerConnection has been closed.</t>
        </section>

        <section title="remoteDescription">
          <t>The remoteDescription method returns a copy of the current remote
          configuration, i.e. what was most recently passed to
          setRemoteDescription, plus any remote candidates that have been
          supplied via processIceMessage.</t>

          <t>TODO: Do we need to expose accessors for both the current and
          proposed remote description?</t>

          <t>A null object will be returned if the remote description has not
          yet been established, or if the PeerConnection has been closed.</t>
        </section>

        <section title="updateIce">
          <t>The updateIce method allows the configuration of the ICE Agent to
          be changed during the session, primarily for changing which types of
          local candidates are provided to the application and used for
          connectivity checks. A callee may initially configure the ICE Agent
          to use only relay candidates, to avoid leaking location information,
          but update this configuration to use all candidates once the call is
          accepted.</t>

          <t>Regardless of the configuration, the gathering process collects
          all available candidates, but excluded candidates will not be
          surfaced in onicecandidate callback or used for connectivity
          checks.</t>

          <t>This call may result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>

        <section title="addIceCandidate">
          <t>The addIceCandidate method provides a remote candidate to the ICE
          Agent, which, if parsed successfully, will be added to the remote
          description according to the rules defined for Trickle ICE.
          Connectivity checks will be sent to the new candidate.</t>

          <t>This call will result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>
      </section>
    </section>

    <section title="SDP Interaction Procedures">
      <t>This section describes the specific procedures to be followed when
      creating and parsing SDP objects.</t>

      <section title="SDP Requirements Overview">
        <t>The key specifications that govern creation and processing of
        offers and answers are listed below. This list is derived from <xref
        target="I-D.ietf-rtcweb-rtp-usage"></xref>. <list style="format R-%d">
            <!-- TODO - fix the refs in here -->

            <t><xref target="RFC4566"></xref> is the base SDP specification
            and MUST be implemented.</t>

            <t>The <xref target="RFC5888"></xref> grouping framework MUST be
            implemented for signaling grouping information, and MUST be used
            to identify m= lines via the a=mid attribute.</t>

            <t><xref target="RFC5124"></xref> MUST be supported for signaling
            RTP/SAVPF RTP profile.</t>

            <t><xref target="RFC4585"></xref> MUST be implemented to signal
            RTCP based feedback.</t>

            <t><xref target="RFC5245"></xref> MUST be implemented for
            signaling the ICE candidate lines corresponding to each media
            stream.</t>

            <t><xref target="RFC5761"></xref> MUST be implemented to signal
            multiplexing of RTP and RTCP.</t>

            <t>The SDP atributes of "sendonly", "recvonly", "inactive", and
            "sendrecv" from <xref target="RFC4566"></xref> MUST be implemented
            to signal information about media direction.</t>

            <t><xref target="RFC5576"></xref> MUST be implemented to signal
            RTP SSRC values.</t>

            <t><xref target="RFC5763"></xref> MUST be implemented to signal
            DTLS certificate fingerprints.</t>

            <t><xref target="RFC5506"></xref> MAY be implemented to signal
            Reduced-Size RTCP messages.</t>

            <t><xref target="RFC3556"></xref> with bandwidth modifiers MAY be
            supported for specifying RTCP bandwidth as a fraction of the media
            bandwidth, RTCP fraction allocated to the senders and setting
            maximum media bit-rate boundaries.</t>

            <t><xref target="RFC4568"></xref> MUST NOT be implemented to
            signal SDES SRTP keying information.</t>

            <t>A <xref target="I-D.ietf-mmusic-msid"></xref> MUST be
            supported, in order to signal associations between RTP objects and
            W3C MediaStreams and MediaStreamTracks in a standard way.</t>

            <t>The bundle mechanism in <xref
            target="I-D.ietf-mmusic-sdp-bundle-negotiation"></xref> MUST be
            supported to signal the use or multiplexing RTP somethings on a
            single UDP port, in order to avoid excessive use of port number
            resources.</t>
          </list></t>

        <t>As required by <xref target="RFC4566"></xref> Section 5.13 JSEP
        implementations MUST ignore unknown attributes (a=) lines.</t>

        <t>Example SDP for RTCWeb call flows can be found in <xref
        target="I-D.nandakumar-rtcweb-sdp"></xref>. [TODO: since we are
        starting to specify how to handle SDP in this document, should these
        call flows be merged into this document, or this link moved to the
        examples section?]</t>
      </section>

      <section anchor="sec-create-offer" title="Constructing an Offer">
        <t>When createOffer is called, a new SDP description must be created
        that includes the functionality specified in <xref
        target="I-D.ietf-rtcweb-rtp-usage"></xref>. The exact details of this
        process are explained below.</t>

        <section title="Initial Offers">
          <t>When createOffer is called for the first time, the result is
          known as the initial offer.</t>

          <t>The first step in generating an initial offer is to generate
          session-level attributes, as specified in <xref
          target="RFC4566"></xref>, Section 5. Specifically: <list
              style="symbols">
              <t>The first SDP line MUST be "v=0", as specified in <xref
              target="RFC4566"></xref>, Section 5.1</t>

              <t>The second SDP line MUST be an "o=" line, as specified in
              <xref target="RFC4566"></xref>, Section 5.2. The value of the
              &lt;username&gt; field SHOULD be "-". The value of the
              &lt;sess-id&gt; field SHOULD be a cryptographically random
              number. To ensure uniqueness, this number SHOULD be at least 64
              bits long. The value of the &lt;sess-version&gt; field SHOULD be
              zero. The value of the &lt;nettype&gt; &lt;addrtype&gt;
              &lt;unicast-address&gt; tuple SHOULD be set to a non-meaningful
              address, such as IN IP4 0.0.0.0, to prevent leaking the local
              address in this field. As mentioned in <xref
              target="RFC4566"></xref>, the entire o= line needs to be unique,
              but selecting a random number for &lt;sess-id&gt; is sufficient
              to accomplish this.</t>

              <t>The third SDP line MUST be a "s=" line, as specified in <xref
              target="RFC4566"></xref>, Section 5.3; a single space SHOULD be
              used as the session name, e.g. "s= "</t>

              <t>Session Information ("i="), URI ("u="), Email Address ("e="),
              Phone Number ("p="), Bandwidth ("b="), Repeat Times ("r="), and
              Time Zones ("z=") lines are not useful in this context and
              SHOULD NOT be included.</t>

              <t>Encryption Keys ("k=") lines do not provide sufficient
              security and MUST NOT be included.</t>

              <t>A "t=" line MUST be added, as specified in <xref
              target="RFC4566"></xref>, Section 5.9; both &lt;start-time&gt;
              and &lt;stop-time&gt; SHOULD be set to zero, e.g. "t=0 0".</t>
            </list></t>

          <t>The next step is to generate m= sections for each
          MediaStreamTrack that has been added to the PeerConnection via the
          addStream method. Note that this method takes a MediaStream, which
          can contain multiple MediaStreamTracks, and therefore multiple m=
          sections can be generated even if addStream is only called once.</t>

          <t>Each m= section should be generated as specified in <xref
          target="RFC4566"></xref>, Section 5.14. The &lt;proto&gt; field MUST
          be set to "RTP/SAVPF". If a m= section is not being bundled into
          another m= section, it MUST generate a unique set of ICE credentials
          and gather its own set of candidates. Otherwise, it MUST use the
          same ICE credentials and candidates that were used in the m= section
          that it is being bundled into. For DTLS, all m= sections MUST use
          the same certificate [OPEN ISSUE: how this is configured] and will
          therefore have the same fingerprint values.</t>

          <t>Each m= section MUST include the following: <list style="symbols">
              <t>An "a=mid" line, as specified in <xref
              target="RFC5888"></xref>, Section 4.</t>

              <t>An "a=msid" line, as specified in <xref
              target="I-D.ietf-mmusic-msid"></xref>, Section 2.</t>

              <t>[OPEN ISSUE: Use of App Token versus stream-correlator ]</t>

              <t>An "a=sendrecv" line, as specified in <xref
              target="RFC3264"></xref>, Section 5.1.</t>

              <t>For each supported codec, "a=rtpmap" and "a=fmtp" lines, as
              specified in <xref target="RFC4566"></xref>, Section 6. For
              audio, the codecs specified in <xref
              target="I-D.ietf-rtcweb-audio"></xref>, Section 3, MUST be be
              supported.</t>

              <t>For each primary codec where RTP retransmission should be
              used, a corresponding "a=rtpmap" line indicating "rtx" with the
              clock rate of the primary codec and an "a=fmtp" line that
              references the payload type fo the primary codec, as specified
              in <xref target="RFC4588"></xref>, Section 8.1.</t>

              <t>For each supported FEC mechanism, a corresponding "a=rtpmap"
              line indicating the desired FEC codec.</t>

              <t>"a=ice-ufrag" and "a=ice-passwd" lines, as specified in <xref
              target="RFC5245"></xref>, Section 15.4.</t>

              <t>An "a=ice-options" line, with the "trickle" option, as
              specified in <xref target="I-D.ivov-mmusic-trickle-ice"></xref>,
              Section 4.</t>

              <t>For each candidate that has been gathered during the most
              recent gathering phase, an "a=candidate" line, as specified in
              <xref target="RFC5245"></xref>, Section 4.3., paragraph 3.</t>

              <t>For the current default candidate, a "c=" line, as specific
              in <xref target="RFC5245"></xref>, Section 4.3., paragraph 6.
              [OPEN ISSUE, pending resolution in mmusic: If no candidates have
              yet been gathered yet, the default candidate should be set to
              the null value defined in <xref
              target="I-D.ivov-mmusic-trickle-ice"></xref>, Section 5.1.]</t>

              <t>An "a=fingerprint" line, as specified in <xref
              target="RFC4572"></xref>, Section 5. Use of the SHA-256
              algorithm for the fingerprint is REQUIRED; if the browser also
              supports stronger hashes, additional "a=fingerprint" lines with
              these hashes MAY also be added.</t>

              <t>An "a=setup" line, as specified in <xref
              target="RFC4145"></xref>, Section 4, and clarified for use in
              DTLS-SRTP scenarios in <xref target="RFC5763"></xref>, Section
              5. The role value in the offer MUST be "actpass".</t>

              <t>An "a=rtcp-mux" line, as specified in <xref
              target="RFC5761"></xref>, Section 5.1.1.</t>

              <t>An "a=rtcp-rsize" line, as specified in <xref
              target="RFC5506"></xref>, Section 5.</t>

              <t>For each supported RTP header extension, an "a=extmap" line,
              as specified in <xref target="RFC5285"></xref>, Section 5. The
              list of header extensions that SHOULD/MUST be supported is
              specified in <xref target="I-D.ietf-rtcweb-rtp-usage"></xref>,
              Section 5.2. Any header extensions that require encryption MUST
              be specified as indicated in <xref target="RFC6904"></xref>,
              Section 4.</t>

              <t>For each supported RTCP feedback mechanism, an "a=rtcp-fb"
              mechanism, as specified in <xref target="RFC4585"></xref>,
              Section 4.2. The list of RTCP feedback mechanisms that
              SHOULD/MUST be supported is specified in <xref
              target="I-D.ietf-rtcweb-rtp-usage"></xref>, Section 5.1.</t>

              <t>An "a=ssrc" line, as specified in <xref
              target="RFC5576"></xref>, Section 4.1, indicating the SSRC to be
              used for sending media.</t>

              <t>If RTX is supported for this media type, another "a=ssrc"
              line with the RTX SSRC, and an "a=ssrc-group" line, as specified
              in <xref target="RFC5576"></xref>, section 4.2, with semantics
              set to "FID" and including the primary and RTX SSRCs.</t>

              <t>If FEC is supported for this media type, another "a=ssrc"
              line with the FEC SSRC, and an "a=ssrc-group" line, as specified
              in <xref target="RFC5576"></xref>, section 4.2, with semantics
              set to "FEC" and including the primary and FEC SSRCs.</t>

              <t>[OPEN ISSUE: Handling of a=imageattr]</t>

              <t>[TODO: bundle-only]</t>
            </list></t>

          <t>Lastly, if a data channel has been created, a m= section MUST be
          generated for data. The &lt;media&gt; field MUST be set to
          "application" and the &lt;proto&gt; field MUST be set to
          "DTLS/SCTP", as specified in <xref
          target="I-D.ietf-mmusic-sctp-sdp"></xref>, Section 3. The "a=mid",
          "a=ice-ufrag", "a=ice-passwd", "a=ice-options", "a=candidate",
          "a=fingerprint", and "a=setup" lines MUST be included as mentioned
          above. [OPEN ISSUE: additional SCTP-specific stuff to be included,
          as indicated in <xref
          target="I-D.jesup-rtcweb-data-protocol"></xref> (currently
          none)]</t>

          <t>Once all m= sections have been generated, a session-level
          "a=group" attribute MUST be added as specified in <xref
          target="RFC5888"></xref>. This attribute MUST have semantics
          "BUNDLE", and identify the m= sections to be bundled. [OPEN ISSUE:
          Need to determine exactly how this decision is made.]</t>

          <t>Attributes that are common between all m= sections MAY be moved
          to session-level, if desired.</t>

          <t>Attributes other than the ones specified above MAY be included,
          except for the following attributes which are specifically
          incompatible with the requirements of <xref
          target="I-D.ietf-rtcweb-rtp-usage"></xref>, and MUST NOT be
          included: <list style="symbols">
              <t>"a=crypto"</t>

              <t>"a=key-mgmt"</t>

              <t>"a=ice-lite"</t>
            </list></t>

          <t>Note that when BUNDLE is used, any additional attributes that are
          added MUST follow the advice in <xref
          target="I-D.nandakumar-mmusic-sdp-mux-attributes"></xref> on how
          those attributes interact with BUNDLE.</t>
        </section>

        <section title="Subsequent Offers">
          <t>When createOffer is called a second (or later) time, the
          processing is different, depending on the current signaling
          state.</t>

          <t>If the initial offer was not applied using setLocalDescription,
          meaning the PeerConnection is still in the "stable" state, the steps
          for generating an initial offer should be followed, with this
          exception: <list style="symbols">
              <t>The "o=" line MUST stay the same.</t>
            </list></t>

          <t>If the initial offer was applied using setLocalDescription, but
          an answer from the remote side has not yet been applied, meaning the
          PeerConnection is still in the "local-offer" state, the steps for
          generating an initial offer should be followed, with these
          exceptions: <list style="symbols">
              <t>The "o=" line MUST stay the same, except for the
              &lt;session-version&gt; field, which MUST increase by 1 from the
              previously applied local description.</t>

              <t>The "s=" and "t=" lines MUST stay the same.</t>

              <t>Each "a=mid" line MUST stay the same.</t>

              <t>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the
              same.</t>

              <t>For MediaStreamTracks that are still present, the "a=msid",
              "a=ssrc", and "a=ssrc-group" lines MUST stay the same.</t>

              <t>If any MediaStreamTracks have been removed, either through
              the removeStream method or by removing them from an added
              MediaStream, their m= sections MUST be marked as recvonly by
              changing the value of the <xref target="RFC3264"></xref>
              directional attribute to "a=recvonly". The "a=msid", "a=ssrc",
              and "a=ssrc-group" lines MUST be removed from the associated m=
              sections.</t>
            </list></t>

          <t>If the initial offer was applied using setLocalDescription, and
          an answer from the remote side has been applied using
          setRemoteDescription, meaning the PeerConnection is in the
          "remote-pranswer" or "stable" states, an offer is generated based on
          the negotiated session descriptions by following the steps mentioned
          for the "local-offer" state above, along with these exceptions:
          [OPEN ISSUE: should this be permitted in the remote-pranswer state?]
          <list style="symbols">
              <t>If a m= section was rejected, i.e. has had its port set to
              zero in either the local or remote description, it MUST remain
              rejected and have a zero port in the new offer, as indicated in
              RFC3264, Section 5.1.</t>

              <t>If a m= section exists in the current local description, but
              has its state set to inactive or recvonly, and a new
              MediaStreamTrack is added, the previously existing m= section
              MUST be recycled instead of creating a new m= section. [OPEN
              ISSUE: Nail down exactly what this means. Should the codecs
              remain the same? (No.) Should ICE restart? (No.) Can the "a=mid"
              attribute be changed? (Yes?)]</t>

              <t>If a m= section exists in the current local description, but
              does not have an associated MediaStreamTrack (i.e. it is
              inactive or recvonly), a corresponding m= section MUST be
              generated in the new offer, but without "a=msid", "a=ssrc", or
              "a=ssrc-group" attributes, and the appropriate directional
              attribute must be specified.</t>
            </list></t>

          <t>In addition, for each previously existing, non-rejected m=
          section in the new offer, the following adjustments are made based
          on the contents of the corresponding m= section in the current
          remote description: <list style="symbols">
              <t>The m= line and corresponding "a=rtpmap" and "a=fmtp" lines
              MUST only include codecs present in the remote description.</t>

              <t>The RTP header extensions MUST only include those that are
              present in the remote description.</t>

              <t>The RTCP feedback extensions MUST only include those that are
              present in the remote description.</t>

              <t>The "a=rtcp-mux" line MUST only be added if present in the
              remote description.</t>

              <t>The "a=rtcp-rsize" line MUST only be added if present in the
              remote description.</t>
            </list></t>
        </section>

        <section title="Constraints Handling">
          <t>The createOffer method takes as a parameter a MediaConstraints
          object. Special processing is performed when generating a SDP
          description if the following constraints are present.</t>

          <section title="OfferToReceiveAudio">
            <t>If the "OfferToReceiveAudio" constraint is specified, with a
            value of "true", the offer MUST include a non-rejected m= section
            with media type "audio", even if no audio MediaStreamTrack has
            been added to the PeerConnection. This allows the offerer to
            receive audio even when not sending it; accordingly, the
            directional attribute on the audio m= section MUST be set to
            recvonly. If this constraint is specified when an audio
            MediaStreamTrack has already been added to the PeerConnection, or
            a non-rejected m= section with media type "audio" previously
            existed, it has no effect.</t>
          </section>

          <section title="OfferToReceiveVideo">
            <t>If the "OfferToReceiveAudio" constraint is specified, with a
            value of "true", the offer MUST include a m= section with media
            type "video", even if no video MediaStreamTrack has been added to
            the PeerConnection. This allows the offerer to receive video even
            when not sending it; accordingly, the directional attribute on the
            video m= section MUST be set to recvonly. If this constraint is
            specified when an video MediaStreamTrack has already been added to
            the PeerConnection, or a non-rejected m= section with media type
            "video" previously existed, it has no effect.</t>
          </section>

          <section title="VoiceActivityDetection">
            <t>If the "VoiceActivityDetection" constraint is specified, with a
            value of "true", the offer MUST indicate support for silence
            suppression by including comfort noise ("CN") codecs for each
            supported clock rate, as specified in <xref
            target="RFC3389"></xref>, Section 5.1. [OPEN issue: should this do
            anything in signaling, or should it just control built-in DTX
            modes in audio codecs? Opus has built-in DTX, but G.711 does
            not.]</t>
          </section>

          <section title="IceRestart">
            <t>If the "IceRestart" constraint is specified, with a value of
            "true", the offer MUST indicate an ICE restart by generating new
            ICE ufrag and pwd attributes, as specified in RFC5245, Section
            9.1.1.1. If this constraint is specified on an initial offer, it
            has no effect (since a new ICE ufrag and pwd are already
            generated).</t>
          </section>
        </section>
      </section>

      <section title="Generating an Answer">
        <t>When createAnswer is called, a new SDP description must be created
        that is compatible with the supplied remote description as well as the
        requirements specified in <xref
        target="I-D.ietf-rtcweb-rtp-usage"></xref>. The exact details of this
        process are explained below.</t>

        <section title="Initial Answers">
          <t>When createAnswer is called for the first time after a remote
          description has been provided, the result is known as the initial
          answer. If no remote description has been installed, an answer
          cannot be generated, and an error MUST be returned.</t>

          <t>Note that the remote description SDP may not have been created by
          a WebRTC endpoint and may not conform to all the requirements listed
          in <xref target="sec-create-offer"></xref>. For many cases, this is
          not a problem. However, if any mandatory SDP attributes are missing,
          or functionality listed as mandatory-to-use is not present (e.g.
          ICE, DTLS) [TODO: find reference for this], this MUST be treated as
          an error. [OPEN ISSUE: Should this cause setRemoteDescription to
          fail, or should this cause createAnswer to reject those particular
          m= sections?]</t>

          <t>The first step in generating an initial answer is to generate
          session-level attributes. The process here is identical to that
          indicated in the Initial Offers section above, with the addition
          that</t>

          <t>The next step is to generate m= sections for each m= section that
          is present in the remote offer, as specified in <xref
          target="RFC3264"></xref>, Section 6. For the purposes of this
          discussion, any session-level attributes in the offer that are also
          valid as media-level attributes SHALL be considered to be present in
          each m= section.</t>

          <t>If any of the offered m= sections have been rejected, by stopping
          the associated remote MediaStreamTrack, the corresponding m= section
          in the answer MUST be marked as rejected by setting the port in the
          m= line to zero, as indicated in <xref target="RFC3264"></xref>,
          Section 6., and processing continues with the next m= section.</t>

          <t>For each non-rejected m= section of a given media type, if there
          is a local MediaStreamTrack of the specified type which has been
          added to the PeerConnection via addStream and not yet associated
          with a m= section, the MediaStreamTrack is associated with the m=
          section at this time. If there are more m= sections of a certain
          type than MediaStreamTracks, some m= sections will not have an
          associated MediaStreamTrack. If there are more MediaStreamTracks of
          a certain type than m= sections, only the first N MediaStreamTracks
          will be able to be associated in the constructed answer. The
          remainder will need to be associated in a subsequent offer.</t>

          <t>Each m= section should then generated as specified in <xref
          target="RFC3264"></xref>, Section 6.1. The &lt;proto&gt; field MUST
          be set to "RTP/SAVPF". If the offer supports BUNDLE, all m= sections
          to be BUNDLEd must use the same ICE credentials and candidates; all
          m= sections not being BUNDLEd must use unique ICE credentials and
          candidates. Each m= section MUST include the following: <list
              style="symbols">
              <t>If present in the offer, an "a=mid" line, as specified in
              <xref target="RFC5888"></xref>, Section 9.1. The "mid" value
              MUST match that specified in the offer.</t>

              <t>If a local MediaStreamTrack has been associated, an "a=msid"
              line, as specified in <xref
              target="I-D.ietf-mmusic-msid"></xref>, Section 2.</t>

              <t>[OPEN ISSUE: Use of App Token versus stream-correlator ]</t>

              <t>If a local MediaStreamTrack has been associated, an
              "a=sendrecv" line, as specified in <xref
              target="RFC3264"></xref>, Section 6.1. If no local
              MediaStreamTrack has been associated, an "a=recvonly" line.
              [TODO: handle non-sendrecv offered m= sections]</t>

              <t>For each supported codec that is present in the offer,
              "a=rtpmap" and "a=fmtp" lines, as specified in <xref
              target="RFC4566"></xref>, Section 6, and <xref
              target="RFC3264"></xref>, Section 6.1. For audio, the codecs
              specified in <xref target="I-D.ietf-rtcweb-audio"></xref>,
              Section 3, MUST be be supported. Note that for simplicity, the
              answerer MAY use different payload types for codecs than the
              offerer, as it is not prohibited by Section 6.1.</t>

              <t>If "rtx" is present in the offer, for each primary codec
              where RTP retransmission should be used, a corresponding
              "a=rtpmap" line indicating "rtx" with the clock rate of the
              primary codec and an "a=fmtp" line that references the payload
              type fo the primary codec, as specified in <xref
              target="RFC4588"></xref>, Section 8.1.</t>

              <t>For each supported FEC mechanism that is present in the
              offer, a corresponding "a=rtpmap" line indicating the desired
              FEC codec.</t>

              <t>"a=ice-ufrag" and "a=ice-passwd" lines, as specified in <xref
              target="RFC5245"></xref>, Section 15.4.</t>

              <t>If the "trickle" ICE option is present in the offer, an
              "a=ice-options" line, with the "trickle" option, as specified in
              <xref target="I-D.ivov-mmusic-trickle-ice"></xref>, Section
              4.</t>

              <t>For each candidate that has been gathered during the most
              recent gathering phase, an "a=candidate" line, as specified in
              <xref target="RFC5245"></xref>, Section 4.3., paragraph 3.</t>

              <t>For the current default candidate, a "c=" line, as specific
              in <xref target="RFC5245"></xref>, Section 4.3., paragraph 6.
              [OPEN ISSUE, pending resolution in mmusic: If no candidates have
              yet been gathered yet, the default candidate should be set to
              the null value defined in <xref
              target="I-D.ivov-mmusic-trickle-ice"></xref>, Section 5.1.]</t>

              <t>An "a=fingerprint" line, as specified in <xref
              target="RFC4572"></xref>, Section 5. Use of the SHA-256
              algorithm for the fingerprint is REQUIRED; if the browser also
              supports stronger hashes, additional "a=fingerprint" lines with
              these hashes MAY also be added.</t>

              <t>An "a=setup" line, as specified in <xref
              target="RFC4145"></xref>, Section 4, and clarified for use in
              DTLS-SRTP scenarios in <xref target="RFC5763"></xref>, Section
              5. The role value in the answer MUST be "active" or "passive";
              the "active" role is RECOMMENDED.</t>

              <t>If present in the offer, an "a=rtcp-mux" line, as specified
              in <xref target="RFC5761"></xref>, Section 5.1.1.</t>

              <t>If present in the offer, an "a=rtcp-rsize" line, as specified
              in <xref target="RFC5506"></xref>, Section 5.</t>

              <t>For each supported RTP header extension that is present in
              the offer, an "a=extmap" line, as specified in <xref
              target="RFC5285"></xref>, Section 5. The list of header
              extensions that SHOULD/MUST be supported is specified in <xref
              target="I-D.ietf-rtcweb-rtp-usage"></xref>, Section 5.2. Any
              header extensions that require encryption MUST be specified as
              indicated in <xref target="RFC6904"></xref>, Section 4.</t>

              <t>For each supported RTCP feedback mechanism that is present in
              the offer, an "a=rtcp-fb" mechanism, as specified in <xref
              target="RFC4585"></xref>, Section 4.2. The list of RTCP feedback
              mechanisms that SHOULD/MUST be supported is specified in <xref
              target="I-D.ietf-rtcweb-rtp-usage"></xref>, Section 5.1.</t>

              <t>If a local MediaStreamTrack has been associated, an "a=ssrc"
              line, as specified in <xref target="RFC5576"></xref>, Section
              4.1, indicating the SSRC to be used for sending media.</t>

              <t>If a local MediaStreamTrack has been associated, and RTX has
              been negotiated for this m= section, another "a=ssrc" line with
              the RTX SSRC, and an "a=ssrc-group" line, as specified in <xref
              target="RFC5576"></xref>, section 4.2, with semantics set to
              "FID" and including the primary and RTX SSRCs.</t>

              <t>If a local MediaStreamTrack has been associated, and FEC has
              been negotiated for this m= section, another "a=ssrc" line with
              the FEC SSRC, and an "a=ssrc-group" line, as specified in <xref
              target="RFC5576"></xref>, section 4.2, with semantics set to
              "FEC" and including the primary and FEC SSRCs.</t>

              <t>[OPEN ISSUE: Handling of a=imageattr]</t>

              <t>[TODO: bundle-only]</t>
            </list></t>

          <t>If a data channel m= section has been offered, a m= section MUST
          also be generated for data. The &lt;media&gt; field MUST be set to
          "application" and the &lt;proto&gt; field MUST be set to
          "DTLS/SCTP", as specified in <xref
          target="I-D.ietf-mmusic-sctp-sdp"></xref>, Section 3. The "a=mid",
          "a=ice-ufrag", "a=ice-passwd", "a=ice-options", "a=candidate",
          "a=fingerprint", and "a=setup" lines MUST be included as mentioned
          above. [OPEN ISSUE: additional SCTP-specific stuff to be included,
          as indicated in <xref
          target="I-D.jesup-rtcweb-data-protocol"></xref> (currently
          none)]</t>

          <t>[TODO: processing of BUNDLE group]</t>

          <t>Attributes that are common between all m= sections MAY be moved
          to session-level, if desired.</t>

          <t>The attributes prohibited in creation of offers are also
          prohibited in the creation of answers.</t>
        </section>

        <section title="Subsequent Answers"></section>

        <section title="Constraints Handling"></section>
      </section>

      <section title="Parsing an Offer"></section>

      <section title="Parsing an Answer"></section>

      <section title="Applying a Local Description"></section>

      <section title="Applying a Remote Description"></section>
    </section>

    <section title="Configurable SDP Parameters">
      <t>Note: This section is still very early and is likely to significantly
      change as we get a better understanding of a) the use cases for this b)
      the implications at the protocol level c) feedback from implementors on
      what they can do.</t>

      <t>The following elements of the SDP media description MUST NOT be
      changed between the createOffer and the setLocalDescription, since they
      reflect transport attributes that are solely under browser control, and
      the browser MUST NOT honor an attempt to change them:</t>

      <t><list style="symbols">
          <t>The number, type and port number of m-lines.</t>

          <t>The generated ICE credentials (a=ice-ufrag and a=ice-pwd).</t>

          <t>The set of ICE candidates and their parameters (a=candidate).</t>
        </list></t>

      <t>The following modifications, if done by the browser to a description
      between createOffer/createAnswer and the setLocalDescription, MUST be
      honored by the browser:</t>

      <t><list style="symbols">
          <t>Remove or reorder codecs (m=)</t>
        </list></t>

      <t>The following parameters may be controlled by constraints passed into
      createOffer/createAnswer. As an open issue, these changes may also be be
      performed by manipulating the SDP returned from
      createOffer/createAnswer, as indicated above, as long as the
      capabilities of the endpoint are not exceeded (e.g. asking for a
      resolution greater than what the endpoint can encode):</t>

      <t><list style="symbols">
          <t>disable BUNDLE (a=group)</t>

          <t>disable RTCP mux (a=rtcp-mux)</t>

          <t>change send resolution or frame rate</t>

          <t>change desired recv resolution or frame rate</t>

          <t>change maximum total bandwidth (b=) [OPEN ISSUE: need to clarify
          if this is CT or AS - see section 5.8 of <xref
          target="RFC4566"></xref>]</t>

          <t>remove desired AVPF mechanisms (a=rtcp-fb)</t>

          <t>remove RTP header extensions (a=extmap)</t>

          <t>change media send/recv state (a=sendonly/recvonly/inactive)</t>
        </list></t>

      <t>For example, an application could implement call hold by adding an
      a=inactive attribute to its local description, and then applying and
      signaling that description.</t>

      <t>The application can also modify the SDP to reduce the capabilities in
      the offer it sends to the far side in any way the application sees fit,
      as long as it is a valid SDP offer and specifies a subset of what the
      browser is expecting to do.</t>

      <t>As always, the application is solely responsible for what it sends to
      the other party, and all incoming SDP will be processed by the browser
      to the extent of its capabilities. It is an error to assume that all SDP
      is well-formed; however, one should be able to assume that any
      implementation of this specification will be able to process, as a
      remote offer or answer, unmodified SDP coming from any other
      implementation of this specification.</t>
    </section>

    <section title="Security Considerations">
      <t>The intent of the WebRTC protocol suite is to provide an environment
      that is securable by default: all media is encrypted, keys are exchanged
      in a secure fashion, and the Javascript API includes functions that can
      be used to verify the identity of communication partners.</t>
    </section>

    <section title="IANA Considerations">
      <t>This document requires no actions from IANA.</t>
    </section>

    <section title="Acknowledgements">
      <t>Significant text incorporated in the draft as well and review was
      provided by Harald Alvestrand and Suhas Nandakumar. <!-- ACK 1 --> Dan
      Burnett, Neil Stratford, Eric Rescorla, Anant Narayanan, Andrew Hutton,
      Richard Ejzak, <!-- ACK 2 --> <!-- ACK 3 --> <!-- ACK 4 --> and Adam
      Bergkvist all provided valuable feedback on this proposal. <!-- ACK 5 -->
      <!-- ACK 5a --> <!-- ACK 5b --> <!-- ACK 5c --> Matthew Kaufman provided
      the observation that keeping state out of the browser allows a call to
      continue even if the page is reloaded. <!-- ACK 6 --><!-- ACK 7 --></t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <!-- NORM 1 -->

      <reference anchor="RFC5245">
        <front>
          <title>Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <date month="April" year="2010" />
        </front>

        <seriesInfo name="RFC" value="5245" />

        <format octets="285120"
                target="http://www.rfc-editor.org/rfc/rfc5245.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5888">
        <front>
          <title>The Session Description Protocol (SDP) Grouping
          Framework</title>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2010" />

          <abstract>
            <t>In this specification, we define a framework to group "m" lines
            in the Session Description Protocol (SDP) for different purposes.
            This framework uses the "group" and "mid" SDP attributes, both of
            which are defined in this specification. Additionally, we specify
            how to use the framework for two different purposes: for lip
            synchronization and for receiving a media flow consisting of
            several media streams on different transport addresses. This
            document obsoletes RFC 3388. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5888" />

        <format octets="43924"
                target="http://www.rfc-editor.org/rfc/rfc5888.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5761">
        <front>
          <title>Multiplexing RTP Data and Control Packets on a Single
          Port</title>

          <author fullname="C. Perkins" initials="C." surname="Perkins">
            <organization></organization>
          </author>

          <author fullname="M. Westerlund" initials="M." surname="Westerlund">
            <organization></organization>
          </author>

          <date month="April" year="2010" />

          <abstract>
            <t>This memo discusses issues that arise when multiplexing RTP
            data packets and RTP Control Protocol (RTCP) packets on a single
            UDP port. It updates RFC 3550 and RFC 3551 to describe when such
            multiplexing is and is not appropriate, and it explains how the
            Session Description Protocol (SDP) can be used to signal
            multiplexed sessions. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5761" />

        <format octets="31778"
                target="http://www.rfc-editor.org/rfc/rfc5761.txt" type="TXT" />
      </reference>

      <reference anchor="RFC4585">
        <front>
          <title>Extended RTP Profile for Real-time Transport Control Protocol
          (RTCP)-Based Feedback (RTP/AVPF)</title>

          <author fullname="J. Ott" initials="J." surname="Ott">
            <organization></organization>
          </author>

          <author fullname="S. Wenger" initials="S." surname="Wenger">
            <organization></organization>
          </author>

          <author fullname="N. Sato" initials="N." surname="Sato">
            <organization></organization>
          </author>

          <author fullname="C. Burmeister" initials="C." surname="Burmeister">
            <organization></organization>
          </author>

          <author fullname="J. Rey" initials="J." surname="Rey">
            <organization></organization>
          </author>

          <date month="July" year="2006" />

          <abstract>
            <t>Real-time media streams that use RTP are, to some degree,
            resilient against packet losses. Receivers may use the base
            mechanisms of the Real-time Transport Control Protocol (RTCP) to
            report packet reception statistics and thus allow a sender to
            adapt its transmission behavior in the mid-term. This is the sole
            means for feedback and feedback-based error repair (besides a few
            codec-specific mechanisms). This document defines an extension to
            the Audio-visual Profile (AVP) that enables receivers to provide,
            statistically, more immediate feedback to the senders and thus
            allows for short-term adaptation and efficient feedback-based
            repair mechanisms to be implemented. This early feedback profile
            (AVPF) maintains the AVP bandwidth constraints for RTCP and
            preserves scalability to large groups. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4585" />

        <format octets="117762"
                target="http://www.rfc-editor.org/rfc/rfc4585.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5124">
        <front>
          <title>Extended Secure RTP Profile for Real-time Transport Control
          Protocol (RTCP)-Based Feedback (RTP/SAVPF)</title>

          <author fullname="J. Ott" initials="J." surname="Ott">
            <organization></organization>
          </author>

          <author fullname="E. Carrara" initials="E." surname="Carrara">
            <organization></organization>
          </author>

          <date month="February" year="2008" />

          <abstract>
            <t>An RTP profile (SAVP) for secure real-time communications and
            another profile (AVPF) to provide timely feedback from the
            receivers to a sender are defined in RFC 3711 and RFC 4585,
            respectively. This memo specifies the combination of both profiles
            to enable secure RTP communications with feedback.
            [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5124" />

        <format octets="37856"
                target="http://www.rfc-editor.org/rfc/rfc5124.txt" type="TXT" />
      </reference>

      <reference anchor="RFC3261">
        <front>
          <title>SIP: Session Initiation Protocol</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="A. Johnston" initials="A." surname="Johnston">
            <organization></organization>
          </author>

          <author fullname="J. Peterson" initials="J." surname="Peterson">
            <organization></organization>
          </author>

          <author fullname="R. Sparks" initials="R." surname="Sparks">
            <organization></organization>
          </author>

          <author fullname="M. Handley" initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author fullname="E. Schooler" initials="E." surname="Schooler">
            <organization></organization>
          </author>

          <date month="June" year="2002" />

          <abstract>
            <t>This document describes Session Initiation Protocol (SIP), an
            application-layer control (signaling) protocol for creating,
            modifying, and terminating sessions with one or more participants.
            These sessions include Internet telephone calls, multimedia
            distribution, and multimedia conferences. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3261" />

        <format octets="647976"
                target="http://www.rfc-editor.org/rfc/rfc3261.txt" type="TXT" />
      </reference>

      <!-- NORM 2 -->

      <reference anchor="I-D.ietf-rtcweb-audio">
        <front>
          <title>WebRTC Audio Codec and Processing Requirements</title>

          <author fullname="Jean-Marc Valin" initials="J" surname="Valin">
            <organization></organization>
          </author>

          <author fullname="Cary Bran" initials="C" surname="Bran">
            <organization></organization>
          </author>

          <date day="2" month="August" year="2013" />

          <abstract>
            <t>This document outlines the audio codec and processing
            requirements for WebRTC client application and endpoint
            devices.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-rtcweb-audio-02" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-audio-02.txt"
                type="TXT" />
      </reference>

      <!-- NORM 3 -->

      <reference anchor="I-D.ietf-mmusic-sctp-sdp">
        <front>
          <title>Stream Control Transmission Protocol (SCTP)-Based Media
          Transport in the Session Description Protocol (SDP)</title>

          <author fullname="Salvatore Loreto" initials="S" surname="Loreto">
            <organization></organization>
          </author>

          <author fullname="Gonzalo Camarillo" initials="G"
                  surname="Camarillo">
            <organization></organization>
          </author>

          <date day="30" month="June" year="2013" />

          <abstract>
            <t>SCTP (Stream Control Transmission Protocol) is a transport
            protocol used to establish associations between two endpoints.
            This document describes how to express media transport over SCTP
            in SDP (Session Description Protocol). This document defines the
            'SCTP', 'SCTP/DTLS' and 'DTLS/SCTP' protocol identifiers for
            SDP.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-mmusic-sctp-sdp-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sctp-sdp-04.txt"
                type="TXT" />
      </reference>

      <!-- NORM 4 -->

      <reference anchor="RFC4572">
        <front>
          <title>Connection-Oriented Media Transport over the Transport Layer
          Security (TLS) Protocol in the Session Description Protocol
          (SDP)</title>

          <author fullname="J. Lennox" initials="J." surname="Lennox">
            <organization></organization>
          </author>

          <date month="July" year="2006" />

          <abstract>
            <t>This document specifies how to establish secure
            connection-oriented media transport sessions over the Transport
            Layer Security (TLS) protocol using the Session Description
            Protocol (SDP). It defines a new SDP protocol identifier,
            'TCP/TLS'. It also defines the syntax and semantics for an SDP
            'fingerprint' attribute that identifies the certificate that will
            be presented for the TLS session. This mechanism allows media
            transport over TLS connections to be established securely, so long
            as the integrity of session descriptions is
            assured.&lt;/t&gt;&lt;t&gt; This document extends and updates RFC
            4145. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4572" />

        <format octets="38658"
                target="http://www.rfc-editor.org/rfc/rfc4572.txt" type="TXT" />
      </reference>

      <!-- NORM 5 -->

      <reference anchor="RFC4145">
        <front>
          <title>TCP-Based Media Transport in the Session Description Protocol
          (SDP)</title>

          <author fullname="D. Yon" initials="D." surname="Yon">
            <organization></organization>
          </author>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <date month="September" year="2005" />

          <abstract>
            <t>This document describes how to express media transport over TCP
            using the Session Description Protocol (SDP). It defines the SDP
            'TCP' protocol identifier, the SDP 'setup' attribute, which
            describes the connection setup procedure, and the SDP 'connection'
            attribute, which handles connection reestablishment.
            [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4145" />

        <format octets="30225"
                target="http://www.rfc-editor.org/rfc/rfc4145.txt" type="TXT" />
      </reference>

      <!-- NORM 6 -->

      <reference anchor="I-D.nandakumar-mmusic-sdp-mux-attributes">
        <front>
          <title>A Framework for SDP Attributes when Multiplexing</title>

          <author fullname="Suhas Nandakumar" initials="S"
                  surname="Nandakumar">
            <organization></organization>
          </author>

          <date day="15" month="July" year="2013" />

          <abstract>
            <t>The Session Description Protocol (SDP) provides mechanisms to
            describe attributes of multimedia sessions and of individual media
            streams (e.g., Real-time Transport Protocol (RTP) sessions) within
            a multimedia session. In the RTCWeb WG, there is a need to use a
            single 5-tuple for sending and receiving media associated with
            multiple media descriptions ("m=" lines). Such a requirement has
            raised concerns over the semantic implications of the SDP
            attributes associated with the RTP Sessions multiplexed over a
            single transport layer flow. The scope of this specification is to
            provide a framework for analyzing the multiplexing characteristics
            of SDP attributes. The specification also categorizes existing
            attributes based on the framework described herein.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-nandakumar-mmusic-sdp-mux-attributes-03" />

        <format target="http://www.ietf.org/internet-drafts/draft-nandakumar-mmusic-sdp-mux-attributes-03.txt"
                type="TXT" />

        <format target="http://www.ietf.org/internet-drafts/draft-nandakumar-mmusic-sdp-mux-attributes-03.pdf"
                type="PDF" />
      </reference>

      <!-- NORM 7 -->

      <!-- NORM 8 -->

      <!-- NORM 9 -->

      <!-- NORM 10 -->

      <reference anchor="RFC5285">
        <front>
          <title>A General Mechanism for RTP Header Extensions</title>

          <author fullname="D. Singer" initials="D." surname="Singer">
            <organization></organization>
          </author>

          <author fullname="H. Desineni" initials="H." surname="Desineni">
            <organization></organization>
          </author>

          <date month="July" year="2008" />

          <abstract>
            <t>This document provides a general mechanism to use the header
            extension feature of RTP (the Real-Time Transport Protocol). It
            provides the option to use a small number of small extensions in
            each RTP packet, where the universe of possible extensions is
            large and registration is de-centralized. The actual extensions in
            use in a session are signaled in the setup information for that
            session. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5285" />

        <format octets="36844"
                target="http://www.rfc-editor.org/rfc/rfc5285.txt" type="TXT" />
      </reference>

      <!-- NORM 11 -->

      <reference anchor="RFC6904">
        <front>
          <title>Encryption of Header Extensions in the Secure Real-time
          Transport Protocol (SRTP)</title>

          <author fullname="J. Lennox" initials="J." surname="Lennox">
            <organization></organization>
          </author>

          <date month="April" year="2013" />

          <abstract>
            <t>The Secure Real-time Transport Protocol (SRTP) provides
            authentication, but not encryption, of the headers of Real-time
            Transport Protocol (RTP) packets. However, RTP header extensions
            may carry sensitive information for which participants in
            multimedia sessions want confidentiality. This document provides a
            mechanism, extending the mechanisms of SRTP, to selectively
            encrypt RTP header extensions in SRTP.&lt;/t&gt;&lt;t&gt; This
            document updates RFC 3711, the Secure Real-time Transport Protocol
            specification, to require that all future SRTP encryption
            transforms specify how RTP header extensions are to be
            encrypted.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="6904" />

        <format octets="33486"
                target="http://www.rfc-editor.org/rfc/rfc6904.txt" type="TXT" />
      </reference>

      <!-- NORM 12 -->

      <reference anchor="I-D.ietf-rtcweb-rtp-usage">
        <front>
          <title>Web Real-Time Communication (WebRTC): Media Transport and Use
          of RTP</title>

          <author fullname="Colin Perkins" initials="C" surname="Perkins">
            <organization></organization>
          </author>

          <author fullname="Magnus Westerlund" initials="M"
                  surname="Westerlund">
            <organization></organization>
          </author>

          <author fullname="Joerg Ott" initials="J" surname="Ott">
            <organization></organization>
          </author>

          <date day="5" month="September" year="2013" />

          <abstract>
            <t>The Web Real-Time Communication (WebRTC) framework provides
            support for direct interactive rich communication using audio,
            video, text, collaboration, games, etc. between two peers'
            web-browsers. This memo describes the media transport aspects of
            the WebRTC framework. It specifies how the Real-time Transport
            Protocol (RTP) is used in the WebRTC context, and gives
            requirements for which RTP features, profiles, and extensions need
            to be supported.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-rtcweb-rtp-usage-09" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-rtp-usage-09.txt"
                type="TXT" />
      </reference>

      <!-- NORM 13 -->

      <reference anchor="I-D.ietf-mmusic-sdp-bundle-negotiation">
        <front>
          <title>Multiplexing Negotiation Using Session Description Protocol
          (SDP) Port Numbers</title>

          <author fullname="Christer Holmberg" initials="C" surname="Holmberg">
            <organization></organization>
          </author>

          <author fullname="Harald Alvestrand" initials="H"
                  surname="Alvestrand">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <date day="14" month="June" year="2013" />

          <abstract>
            <t>This specification defines a new SDP Grouping Framework
            extension, "BUNDLE", that can be used with the Session Description
            Protocol (SDP) Offer/Answer mechanism to negotiate the usage of
            bundled media, which refers to the usage of a single 5-tuple for
            media associated with multiple SDP media descriptions ("m="
            lines).</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ietf-mmusic-sdp-bundle-negotiation-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-bundle-negotiation-04.txt"
                type="TXT" />
      </reference>

      <!-- NORM 14 -->

      <reference anchor="I-D.ietf-mmusic-msid">
        <front>
          <title>Cross Session Stream Identification in the Session
          Description Protocol</title>

          <author fullname="Harald Alvestrand" initials="H"
                  surname="Alvestrand">
            <organization></organization>
          </author>

          <date day="13" month="August" year="2013" />

          <abstract>
            <t>This document specifies a grouping mechanism for RTP media
            streams that can be used to specify relations between media
            streams. This mechanism is used to signal the association between
            the SDP concept of "m-line" and the WebRTC concept of
            "MediaStream" / "MediaStreamTrack" using SDP signaling. This
            document is a work item of the MMUSIC WG, whose discussion list is
            mmusic@ietf.org.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-msid-01" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-msid-01.txt"
                type="TXT" />
      </reference>

      <!-- NORM 15 -->

      <!-- NORM 16 -->

      <!-- NORM 17 -->

      <!-- NORM 18 -->

      <!-- NORM 19 -->

      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723"
                target="http://www.rfc-editor.org/rfc/rfc2119.txt" type="TXT" />

        <format octets="17491"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5777"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>

      <reference anchor="RFC3264">
        <front>
          <title>An Offer/Answer Model with Session Description Protocol
          (SDP)</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3264" />

        <format octets="60854"
                target="http://www.rfc-editor.org/rfc/rfc3264.txt" type="TXT" />
      </reference>

      <reference anchor="RFC4566">
        <front>
          <title>SDP: Session Description Protocol</title>

          <author fullname="M. Handley" initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author fullname="V. Jacobson" initials="V." surname="Jacobson">
            <organization></organization>
          </author>

          <author fullname="C. Perkins" initials="C." surname="Perkins">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4566" />

        <format octets="108820"
                target="http://www.rfc-editor.org/rfc/rfc4566.txt" type="TXT" />
      </reference>
    </references>

    <references title="Informative References">
      <!-- INFORM 1 -->

      <reference anchor="RFC3556">
        <front>
          <title>Session Description Protocol (SDP) Bandwidth Modifiers for
          RTP Control Protocol (RTCP) Bandwidth</title>

          <author fullname="S. Casner" initials="S." surname="Casner">
            <organization></organization>
          </author>

          <date month="July" year="2003" />

          <abstract>
            <t>This document defines an extension to the Session Description
            Protocol (SDP) to specify two additional modifiers for the
            bandwidth attribute. These modifiers may be used to specify the
            bandwidth allowed for RTP Control Protocol (RTCP) packets in a
            Real-time Transport Protocol (RTP) session. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3556" />

        <format octets="15310"
                target="http://www.rfc-editor.org/rfc/rfc3556.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5576">
        <front>
          <title>Source-Specific Media Attributes in the Session Description
          Protocol (SDP)</title>

          <author fullname="J. Lennox" initials="J." surname="Lennox">
            <organization></organization>
          </author>

          <author fullname="J. Ott" initials="J." surname="Ott">
            <organization></organization>
          </author>

          <author fullname="T. Schierl" initials="T." surname="Schierl">
            <organization></organization>
          </author>

          <date month="June" year="2009" />

          <abstract>
            <t>The Session Description Protocol (SDP) provides mechanisms to
            describe attributes of multimedia sessions and of individual media
            streams (e.g., Real-time Transport Protocol (RTP) sessions) within
            a multimedia session, but does not provide any mechanism to
            describe individual media sources within a media stream. This
            document defines a mechanism to describe RTP media sources, which
            are identified by their synchronization source (SSRC) identifiers,
            in SDP, to associate attributes with these sources, and to express
            relationships among sources. It also defines several source-level
            attributes that can be used to describe properties of media
            sources. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5576" />

        <format octets="40454"
                target="http://www.rfc-editor.org/rfc/rfc5576.txt" type="TXT" />
      </reference>

      <reference anchor="RFC5506">
        <front>
          <title>Support for Reduced-Size Real-Time Transport Control Protocol
          (RTCP): Opportunities and Consequences</title>

          <author fullname="I. Johansson" initials="I." surname="Johansson">
            <organization></organization>
          </author>

          <author fullname="M. Westerlund" initials="M." surname="Westerlund">
            <organization></organization>
          </author>

          <date month="April" year="2009" />

          <abstract>
            <t>This memo discusses benefits and issues that arise when
            allowing Real-time Transport Protocol (RTCP) packets to be
            transmitted with reduced size. The size can be reduced if the
            rules on how to create compound packets outlined in RFC 3550 are
            removed or changed. Based on that analysis, this memo defines
            certain changes to the rules to allow feedback messages to be sent
            as Reduced-Size RTCP packets under certain conditions when using
            the RTP/AVPF (Real-time Transport Protocol / Audio-Visual Profile
            with Feedback) profile (RFC 4585). This document updates RFC 3550,
            RFC 3711, and RFC 4585. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5506" />

        <format octets="41011"
                target="http://www.rfc-editor.org/rfc/rfc5506.txt" type="TXT" />
      </reference>

      <!-- INFORM 2 -->

      <!-- INFORM 3 -->

      <!-- INFORM 4 -->

      <reference anchor="RFC3960">
        <front>
          <title>Early Media and Ringing Tone Generation in the Session
          Initiation Protocol (SIP)</title>

          <author fullname="G. Camarillo" initials="G." surname="Camarillo">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="December" year="2004" />

          <abstract>
            <t>This document describes how to manage early media in the
            Session Initiation Protocol (SIP) using two models: the gateway
            model and the application server model. It also describes the
            inputs one needs to consider in defining local policies for
            ringing tone generation. This memo provides information for the
            Internet community.</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="3960" />

        <format octets="31692"
                target="http://www.rfc-editor.org/rfc/rfc3960.txt" type="TXT" />
      </reference>

      <!-- INFORM 5 -->

      <reference anchor="I-D.jesup-rtcweb-data-protocol">
        <front>
          <title>WebRTC Data Channel Protocol</title>

          <author fullname="Randell Jesup" initials="R" surname="Jesup">
            <organization></organization>
          </author>

          <author fullname="Salvatore Loreto" initials="S" surname="Loreto">
            <organization></organization>
          </author>

          <author fullname="Michael Tuexen" initials="M" surname="Tuexen">
            <organization></organization>
          </author>

          <date day="26" month="February" year="2013" />

          <abstract>
            <t>The Web Real-Time Communication (WebRTC) working group is
            charged to provide protocols to support for direct interactive
            rich communication using audio, video, and data between two peers'
            web- browsers. This document specifies an actual (minor) protocol
            for how the JS-layer DataChannel objects provide the data channels
            between the peers.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-jesup-rtcweb-data-protocol-04" />

        <format target="http://www.ietf.org/internet-drafts/draft-jesup-rtcweb-data-protocol-04.txt"
                type="TXT" />
      </reference>

      <!-- INFORM 6 -->

      <reference anchor="RFC4588">
        <front>
          <title>RTP Retransmission Payload Format</title>

          <author fullname="J. Rey" initials="J." surname="Rey">
            <organization></organization>
          </author>

          <author fullname="D. Leon" initials="D." surname="Leon">
            <organization></organization>
          </author>

          <author fullname="A. Miyazaki" initials="A." surname="Miyazaki">
            <organization></organization>
          </author>

          <author fullname="V. Varsa" initials="V." surname="Varsa">
            <organization></organization>
          </author>

          <author fullname="R. Hakenberg" initials="R." surname="Hakenberg">
            <organization></organization>
          </author>

          <date month="July" year="2006" />

          <abstract>
            <t>RTP retransmission is an effective packet loss recovery
            technique for real-time applications with relaxed delay bounds.
            This document describes an RTP payload format for performing
            retransmissions. Retransmitted RTP packets are sent in a separate
            stream from the original RTP stream. It is assumed that feedback
            from receivers to senders is available. In particular, it is
            assumed that Real-time Transport Control Protocol (RTCP) feedback
            as defined in the extended RTP profile for RTCP-based feedback
            (denoted RTP/AVPF) is available in this memo.
            [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="4588" />

        <format octets="76630"
                target="http://www.rfc-editor.org/rfc/rfc4588.txt" type="TXT" />
      </reference>

      <!-- INFORM 7 -->

      <reference anchor="RFC3389">
        <front>
          <title>Real-time Transport Protocol (RTP) Payload for Comfort Noise
          (CN)</title>

          <author fullname="R. Zopf" initials="R." surname="Zopf">
            <organization></organization>
          </author>

          <date month="September" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3389" />

        <format octets="17018"
                target="http://www.rfc-editor.org/rfc/rfc3389.txt" type="TXT" />
      </reference>

      <!-- INFORM 8 -->

      <reference anchor="I-D.ivov-mmusic-trickle-ice">
        <front>
          <title>Trickle ICE: Incremental Provisioning of Candidates for the
          Interactive Connectivity Establishment (ICE) Protocol</title>

          <author fullname="Emil Ivov" initials="E" surname="Ivov">
            <organization></organization>
          </author>

          <author fullname="Eric Rescorla" initials="E" surname="Rescorla">
            <organization></organization>
          </author>

          <author fullname="Justin Uberti" initials="J" surname="Uberti">
            <organization></organization>
          </author>

          <date day="11" month="March" year="2013" />

          <abstract>
            <t>This document describes an extension to the Interactive
            Connectivity Establishment (ICE) protocol that allows ICE agents
            to send and receive candidates incrementally rather than
            exchanging complete lists. With such incremental provisioning, ICE
            agents can begin connectivity checks while they are still
            gathering candidates and considerably shorten the time necessary
            for ICE processing to complete. The above mechanism is also
            referred to as "trickle ICE".</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-ivov-mmusic-trickle-ice-01" />

        <format target="http://www.ietf.org/internet-drafts/draft-ivov-mmusic-trickle-ice-01.txt"
                type="TXT" />
      </reference>

      <!-- INFORM 9 -->

      <!-- INFORM 10 -->

      <!-- INFORM 11 -->

      <!-- INFORM 12 -->

      <!-- INFORM 13 -->

      <!-- INFORM 14 -->

      <!-- INFORM 15 -->

      <reference anchor="I-D.jennings-rtcweb-signaling">
        <front>
          <title>RTCWeb Offer/Answer Protocol (ROAP)</title>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="Randell Jesup" initials="R" surname="Jesup">
            <organization></organization>
          </author>

          <date day="30" month="October" year="2011" />

          <abstract>
            <t>This document describes an protocol used to negotiate media
            between browsers or other compatible devices. This protocol
            provides the state machinery needed to implement the offer/answer
            model (RFC 3264), and defines the semantics and necessary
            attributes of messages that must be exchanged. The protocol uses
            an abstract transport in that it does not actually define how
            these messages are exchanged. Rather, such exchanges are handled
            through web-based transports like HTTP or WebSockets. The protocol
            focuses solely on media negotiation and does not handle call
            control, call processing, or other functions.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-jennings-rtcweb-signaling-01" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.txt"
                type="TXT" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.pdf"
                type="PDF" />
      </reference>

      <!-- INFORM 16 -->

      <reference anchor="I-D.nandakumar-rtcweb-sdp">
        <front>
          <title>SDP for the WebRTC</title>

          <author fullname="Suhas Nandakumar" initials="S"
                  surname="Nandakumar">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <date day="13" month="July" year="2013" />

          <abstract>
            <t>The Web Real-Time Communication (WebRTC) [WEBRTC] working group
            is charged to provide protocol support for direct interactive rich
            communication using audio,video and data between two peers' web
            browsers. With in the WebRTC framework, Session Description
            protocol (SDP) [RFC4566] is used for negotiating session
            capabilities between the peers. Such a negotiataion happens based
            on the SDP Offer/Answer exchange mechanism described in the RFC
            3264 [RFC3264]. This document serves a introductory purpose in
            describing the role of SDP for the most common WebRTC use-cases.
            This SDP examples provided in this document is still a work in
            progress, but aims to align closest to the evolving standards.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-nandakumar-rtcweb-sdp-02" />

        <format target="http://www.ietf.org/internet-drafts/draft-nandakumar-rtcweb-sdp-02.txt"
                type="TXT" />

        <format target="http://www.ietf.org/internet-drafts/draft-nandakumar-rtcweb-sdp-02.pdf"
                type="PDF" />
      </reference>

      <!-- INFORM 17 -->

      <reference anchor="RFC5763">
        <front>
          <title>Framework for Establishing a Secure Real-time Transport
          Protocol (SRTP) Security Context Using Datagram Transport Layer
          Security (DTLS)</title>

          <author fullname="J. Fischl" initials="J." surname="Fischl">
            <organization></organization>
          </author>

          <author fullname="H. Tschofenig" initials="H." surname="Tschofenig">
            <organization></organization>
          </author>

          <author fullname="E. Rescorla" initials="E." surname="Rescorla">
            <organization></organization>
          </author>

          <date month="May" year="2010" />

          <abstract>
            <t>This document specifies how to use the Session Initiation
            Protocol (SIP) to establish a Secure Real-time Transport Protocol
            (SRTP) security context using the Datagram Transport Layer
            Security (DTLS) protocol. It describes a mechanism of transporting
            a fingerprint attribute in the Session Description Protocol (SDP)
            that identifies the key that will be presented during the DTLS
            handshake. The key exchange travels along the media path as
            opposed to the signaling path. The SIP Identity mechanism can be
            used to protect the integrity of the fingerprint attribute from
            modification by intermediate proxies. [STANDARDS-TRACK]</t>
          </abstract>
        </front>

        <seriesInfo name="RFC" value="5763" />

        <format octets="81546"
                target="http://www.rfc-editor.org/rfc/rfc5763.txt" type="TXT" />
      </reference>

      <reference anchor="RFC4568">
        <front>
          <title>Session Description Protocol (SDP) Security Descriptions for
          Media Streams</title>

          <author fullname="F. Andreasen" initials="F." surname="Andreasen">
            <organization></organization>
          </author>

          <author fullname="M. Baugher" initials="M." surname="Baugher">
            <organization></organization>
          </author>

          <author fullname="D. Wing" initials="D." surname="Wing">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4568" />

        <format octets="107881"
                target="http://www.rfc-editor.org/rfc/rfc4568.txt" type="TXT" />
      </reference>

      <reference anchor="W3C.WD-webrtc-20111027"
                 target="http://www.w3.org/TR/2011/WD-webrtc-20111027">
        <front>
          <title>WebRTC 1.0: Real-time Communication Between Browsers</title>

          <author fullname="Adam Bergkvist" initials="A." surname="Bergkvist">
            <organization></organization>
          </author>

          <author fullname="Daniel C. Burnett" initials="D." surname="Burnett">
            <organization></organization>
          </author>

          <author fullname="Anant Narayanan" initials="A." surname="Narayanan">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C." surname="Jennings">
            <organization></organization>
          </author>

          <date day="27" month="October" year="2011" />
        </front>

        <seriesInfo name="World Wide Web Consortium WD"
                    value="WD-webrtc-20111027" />

        <format target="http://www.w3.org/TR/2011/WD-webrtc-20111027"
                type="HTML" />
      </reference>
    </references>

    <section title="JSEP Implementation Examples">
      <section title="Example API Flows">
        <t>Below are several sample flows for the new PeerConnection and
        library APIs, demonstrating when the various APIs are called in
        different situations and with various transport protocols. For clarity
        and simplicity, the createOffer/createAnswer calls are assumed to be
        synchronous in these examples, whereas the actual APIs are async.</t>

        <section title="Call using ROAP">
          <t>This example demonstrates a ROAP call, without the use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   iceCallback(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  {"type":"OFFER", "sdp":offer }

// OFFER arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", msg.sdp);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  iceCallback(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(msg.sdp, null);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  {"type":"ANSWER","sdp":answer }

// ANSWER arrives at Offerer
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererJS->AnswererJS:  {"type":"OK" }
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using XMPP">
          <t>This example demonstrates an XMPP call, making use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              xmpp = createSessionInitiate(offer);
OffererJS->AnswererJS:  <jingle action="session-initiate"/>

OffererJS->OffererUA:   pc.startIce();
OffererUA->OffererJS:   onicecandidate(cand);
OffererJS:              createTransportInfo(cand);
OffererJS->AnswererJS:  <jingle action="transport-info"/>

// session-initiate arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseSessionInitiate(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);

// transport-infos arrive at Answerer
AnswererJS->AnswererUA: candidate = parseTransportInfo(xmpp);
AnswererJS->AnswererUA: pc.addIceCandidate(candidate);
AnswererUA->AnswererJS: onicecandidate(cand)
AnswererJS:             createTransportInfo(cand);
AnswererJS->OffererJS:  <jingle action="transport-info"/>

// transport-infos arrive at Offerer
OffererJS->OffererUA:   candidates = parseTransportInfo(xmpp);
OffererJS->OffererUA:   pc.addIceCandidate(candidates);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS:             xmpp = createSessionAccept(answer);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  <jingle action="session-accept"/>

// session-accept arrives at Offerer
OffererJS:              answer = parseSessionAccept(xmpp);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Adding video to a call, using XMPP">
          <t>This example demonstrates an XMPP call, where the XMPP
          content-add mechanism is used to add video media to an existing
          session. For simplicity, candidate exchange is not shown.</t>

          <t>Note that the offerer for the change to the session may be
          different than the original call offerer. <figure>
              <artwork><![CDATA[
// Offerer adds video stream
OffererJS->OffererUA:   pc.addStream(videoStream)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createContentAdd(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="content-add"/>

// content-add arrives at Answerer
AnswererJS:             offer = parseContentAdd(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS:             xmpp = createContentAccept(answer);
AnswererJS->OffererJS:  <jingle action="content-accept"/>

// content-accept arrives at Offerer
OffererJS:              answer = parseContentAccept(xmpp);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Simultaneous add of video streams, using XMPP">
          <t>This example demonstrates an XMPP call, where new video sources
          are added at the same time to a call that already has video; since
          adding these sources only affects one side of the call, there is no
          conflict. The XMPP description-info mechanism is used to indicate
          the new sources to the remote side. <figure>
              <artwork><![CDATA[
// Offerer and "Answerer" add video streams at the same time
OffererJS->OffererUA:   pc.addStream(offererVideoStream2)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createDescriptionInfo(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="description-info"/>

AnswererJS->AnswererUA: pc.addStream(answererVideoStream2)
AnswererJS->AnswererUA: offer = pc.createOffer(null);
AnswererJS:             xmpp = createDescriptionInfo(offer);
AnswererJS->AnswererUA: pc.setLocalDescription("offer", offer);
AnswererJS->OffererJS:  <jingle action="description-info"/>

// description-info arrives at "Answerer", and is acked
AnswererJS:             offer = parseDescriptionInfo(xmpp);
AnswererJS->OffererJS:  <iq type="result"/>  // ack

// description-info arrives at Offerer, and is acked
OffererJS:              offer = parseDescriptionInfo(xmpp);
OffererJS->AnswererJS:  <iq type="result"/>  // ack

// ack arrives at Offerer; remote offer is used as an answer
OffererJS->OffererUA:   pc.setRemoteDescription("answer", offer);

// ack arrives at "Answerer"; remote offer is used as an answer
AnswererJS->AnswererUA: pc.setRemoteDescription("answer", offer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using SIP">
          <t>This example demonstrates a simple SIP call (e.g. where the
          client talks to a SIP proxy over WebSockets). <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// INVITE arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseInvite(sip);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  onicecandidate(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS:             sip = createResponse(200, answer);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  200 OK w/ SDP

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);
OffererJS->AnswererJS:  ACK

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling early media (e.g. 1-800-GO FEDEX), using SIP">
          <t>This example demonstrates how early media could be handled; for
          simplicity, only the offerer side of the call is shown. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// 180 Ringing is received by offerer, w/ SDP
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("pranswer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererJS->AnswererJS:  ACK
]]></artwork>
            </figure></t>
        </section>
      </section>

      <section title="Example Session Descriptions">
        <section title="createOffer">
          <t>This SDP shows a typical initial offer, created by createOffer
          for a PeerConnection with a single audio MediaStreamTrack, a single
          video MediaStreamTrack, and a single data channel. Host candidates
          have also already been gathered. Note some lines have been broken
          into two lines for formatting reasons.</t>

          <figure>
            <artwork><![CDATA[
v=0
o=- 4962303333179871722 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE audio video data
m=audio 56500 RTP/SAVPF 111 0 8 126
c=IN IP4 192.0.2.1
a=rtcp:56501 IN IP4 192.0.2.1
a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56500
            typ host generation 0
a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56501
            typ host generation 0
a=ice-ufrag:ETEn1v9DoTMB9J4r
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=ice-options:trickle
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass              
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
a=ssrc:1732846380 cname:EocUG1f0fcg/yvY7
a=msid:47017fee-b6c1-4162-929c-a25110252400 
       f83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
m=video 56502 RTP/SAVPF 100 115 116 117
c=IN IP4 192.0.2.1
a=rtcp:56503 IN IP4 192.0.2.1
a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56502
            typ host generation 0
a=candidate:3348148302 2 udp 2113937151 192.0.2.1 56503
            typ host generation 0
a=ice-ufrag:BGKkWnG5GmiUpdIV
a=ice-pwd:mqyWsAjvtKwTGnvhPztQ9mIf
a=ice-options:trickle
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=fingerprint:sha-256
              19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
             :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:115 rtx/90000
a=fmtp:115 apt=100
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:1366781083 cname:EocUG1f0fcg/yvY7
a=ssrc:1366781084 cname:EocUG1f0fcg/yvY7
a=ssrc:1366781085 cname:EocUG1f0fcg/yvY7
a=ssrc-group:FID 1366781083 1366781084
a=ssrc-group:FEC 1366781083 1366781085
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae 
       f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
m=application 56504 DTLS/SCTP 5000
c=IN IP4 192.0.2.1
a=candidate:3348148302 1 udp 2113937151 192.0.2.1 56504
            typ host generation 0
a=ice-ufrag:VD5v2BnbZm3mgP3d
a=ice-pwd:+Jlkuox+VVIUDqxcfIDuTZMH
a=ice-options:trickle
a=mid:data
a=fingerprint:sha-256 19:E2:1C:3B:4B:9F:81:E6:B8:5C:F4:A5:A8:D8:73:04
                     :BB:05:2F:70:9F:04:A9:0E:05:E9:26:33:E8:70:88:A2
a=setup:actpass
a=fmtp:5000 protocol=webrtc-datachannel; streams=10
            ]]></artwork>
          </figure>
        </section>

        <section title="createAnswer">
          <t>This SDP shows a typical initial answer to the above offer,
          created by createAnswer for a PeerConnection with a single audio
          MediaStreamTrack, a single video MediaStreamTrack, and a single data
          channel. Host candidates have also already been gathered. Note some
          lines have been broken into two lines for formatting reasons.</t>

          <figure>
            <artwork><![CDATA[
v=0
o=- 6729291447651054566 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE audio video data
m=audio 20000 RTP/SAVPF 111 0 8 126
c=IN IP4 192.0.2.2
a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20000
            typ host generation 0
a=ice-ufrag:6sFvz2gdLkEwjZEr
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=sendrecv
a=rtcp-mux
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
a=ssrc:3429951804 cname:Q/NWs1ao1HmN4Xa5
a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1a0
m=video 20000 RTP/SAVPF 100 115 116 117
c=IN IP4 192.0.2.2
a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20000
            typ host generation 0
a=ice-ufrag:6sFvz2gdLkEwjZEr
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:115 rtx/90000
a=fmtp:115 apt=100
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:3229706345 cname:Q/NWs1ao1HmN4Xa5
a=ssrc:3229706346 cname:Q/NWs1ao1HmN4Xa5
a=ssrc:3229706347 cname:Q/NWs1ao1HmN4Xa5
a=ssrc-group:FID 3229706345 3229706346
a=ssrc-group:FEC 3229706345 3229706347
a=msid:PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1
       PI39StLS8W7ZbQl1sJsWUXkr3Zf12fJUvzQ1v0
m=application 20000 DTLS/SCTP 5000
c=IN IP4 192.0.2.2
a=candidate:2299743422 1 udp 2113937151 192.0.2.2 20000
            typ host generation 0
a=ice-ufrag:6sFvz2gdLkEwjZEr
a=ice-pwd:cOTZKZNVlO9RSGsEGM63JXT2
a=fingerprint:sha-256 6B:8B:F0:65:5F:78:E2:51:3B:AC:6F:F3:3F:46:1B:35
                     :DC:B8:5F:64:1A:24:C2:43:F0:A1:58:D0:A1:2C:19:08
a=setup:active
a=mid:data
a=fmtp:5000 protocol=webrtc-datachannel; streams=10
            ]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section title="Change log">
      <t>Changes in draft-04: <list style="symbols">
          <t>Filled in sections on createOffer and createAnswer.</t>

          <t>Added SDP examples.</t>

          <t>Fixed references.</t>
        </list></t>

      <t>Changes in draft-03: <list style="symbols">
          <t>Added text describing relationship to W3C specification</t>
        </list></t>

      <t>Changes in draft-02: <list style="symbols">
          <!-- A -->

          <t>Converted from nroff</t>

          <!-- B -->

          <t>Removed comparisons to old approaches abandoned by the working
          group</t>

          <!-- C -->

          <t>Removed stuff that has moved to W3C specification</t>

          <!-- D -->

          <t>Align SDP handling with W3C draft</t>

          <!-- E -->

          <t>Clarified section on forking.</t>

          <!-- F -->

          <!-- G -->

          <!-- H -->

          <!-- I -->

          <!-- J -->

          <!-- K -->

          <!-- L -->
        </list></t>

      <t>Changes in draft-01: <list style="symbols">
          <t>Added diagrams for architecture and state machine.</t>

          <t>Added sections on forking and rehydration.</t>

          <t>Clarified meaning of "pranswer" and "answer".</t>

          <t>Reworked how ICE restarts and media directions are
          controlled.</t>

          <t>Added list of parameters that can be changed in a
          description.</t>

          <t>Updated suggested API and examples to match latest thinking.</t>

          <t>Suggested API and examples have been moved to an appendix.</t>
        </list></t>

      <t>Changes in draft -00: <list style="symbols">
          <t>Migrated from draft-uberti-rtcweb-jsep-02.</t>
        </list></t>
    </section>
  </back>
</rfc>
