<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<?rfc tocdepth="4"?>
<rfc category="std" docName="draft-ietf-rtcweb-jsep-04" ipr="trust200902">
  <front>
    <title abbrev="JSEP">Javascript Session Establishment Protocol</title>

    <author fullname="Justin Uberti" initials="J." surname="Uberti">
      <organization>Google</organization>

      <address>
        <postal>
          <street>747 6th Ave S</street>

          <city>Kirkland</city>

          <region>WA</region>

          <code>98033</code>

          <country>USA</country>
        </postal>

        <email>justin@uberti.name</email>
      </address>
    </author>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <email>fluffy@iii.ca</email>
      </address>
    </author>

    <date day="13" month="September" year="2013" />

    <area>RAI</area>

    <abstract>
      <t>This document describes the mechanisms for allowing a Javascript
      application to control the signaling plane of a multimedia session
      via the interface specified in the W3C RTCPeerConnection API, and
      discusses how this relates to existing signaling protocols.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>This document describes how the W3C WEBRTC RTCPeerConnection
      interface<xref target="W3C.WD-webrtc-20111027"></xref> is used to
      control the setup, management and teardown of a multimedia session.</t>

       <section title="General Design of JSEP">
        <t>The thinking behind WebRTC call setup has been to fully specify and
        control the media plane, but to leave the signaling plane up to the
        application as much as possible. The rationale is that different
        applications may prefer to use different protocols, such as the
        existing SIP or Jingle call signaling protocols, or something custom
        to the particular application, perhaps for a novel use case. In this
        approach, the key information that needs to be exchanged is the
        multimedia session description, which specifies the necessary
        transport and media configuration information necessary to establish
        the media plane.</t>

        <t>The browser environment also has its own challenges that pose
        problems for an embedded signaling state machine. One of these is that
        the user may reload the web page at any time. If the browser is fully in
        charge of the signaling state, this will result in the loss of the call
        when this state is wiped by the reload. However, if the state can be
        stored at the server, and pushed back down to the new page, the call can
        be resumed with minimal interruption.</t>

        <t>With these considerations in mind, this document describes the
        Javascript Session Establishment Protocol (JSEP) that allows for full
        control of the signaling state machine from Javascript. This mechanism
        effectively removes the browser almost completely from the core
        signaling flow; the only interface needed is a way for the application
        to pass in the local and remote session descriptions negotiated by
        whatever signaling mechanism is used, and a way to interact with the ICE
        state machine.</t>

        <t>In this document, the use of JSEP is described as if it always
        occurs between two browsers. Note though in many cases it will actually
        be between a browser and some kind of server, such as a gateway or MCU.
        This distinction is invisible to the browser; it just follows the
        instructions it is given via the API.</t>

        <t>JSEP's handling of session descriptions is simple and
        straightforward. Whenever an offer/answer exchange is needed, the
        initiating side creates an offer by calling a createOffer() API. The
        application optionally modifies that offer, and then uses it to set up
        its local config via the setLocalDescription() API. The offer is then
        sent off to the remote side over its preferred signaling mechanism
        (e.g., WebSockets); upon receipt of that offer, the remote party
        installs it using the setRemoteDescription() API.</t>

        <t>When the call is accepted, the callee uses the createAnswer() API
        to generate an appropriate answer, applies it using
        setLocalDescription(), and sends the answer back to the initiator over
        the signaling channel. When the offerer gets that answer, it installs
        it using setRemoteDescription(), and initial setup is complete. This
        process can be repeated for additional offer/answer exchanges.</t>

        <t>Regarding ICE <xref target="RFC5245"></xref>, JSEP decouples the
        ICE state machine from the overall signaling state machine, as the ICE
        state machine must remain in the browser, because only the browser has
        the necessary knowledge of candidates and other transport info.
        Performing this separation also provides additional flexibility; in
        protocols that decouple session descriptions from transport, such as
        Jingle, the transport information can be sent separately; in protocols
        that don't, such as SIP, the information can be used in the aggregated
        form. Sending transport information separately can allow for faster
        ICE and DTLS startup, since the necessary roundtrips can occur while
        waiting for the remote side to accept the session.</t>

        <t>Through its abstraction of signaling, the JSEP approach does require
        the application to be aware of the signaling process. While the
        application does not need to understand the contents of session
        descriptions to set up a call, the application must call
        the right APIs at the right times, convert the session descriptions
        and ICE information into the defined messages of its chosen signaling
        protocol, and perform the reverse conversion on the messages it receives
        from the other side.</t>

        <t>One way to mitigate this is to provide a Javascript library that
        hides this complexity from the developer; said library would implement
        a given signaling protocol along with its state machine and
        serialization code, presenting a higher level call-oriented interface to
        the application developer. For example, this library could 
        easily adapt the JSEP API into the API that was proposed for the ROAP
        signaling protocol <xref target="I-D.jennings-rtcweb-signaling"></xref>,
        which would perform a ROAP call setup under the covers, interacting with
        the application only when it needs a signaling message to be sent. In
        the same fashion, one could also implement other popular
        signaling protocols, including SIP or Jingle. This allow JSEP to provide
        greater control for the experienced developer without forcing any
        additional complexity on the novice developer.</t>

      </section>

      <section title="Other Approaches Considered">
        <t>One approach that was considered instead of JSEP was to include a
        lightweight signaling protocol. Instead of providing session
        descriptions to the API, the API would produce and consume messages from
        this protocol. While providing a more high-level API, this put more
        control of signaling within the browser, forcing the browser to have to
        understand and handle concepts like signaling glare. In addition, it
        prevented the application from driving the state machine to a desired
        state, as is needed in the page reload case.</t>

        <t>A second approach that was considered but not chosen was to decouple
        the management of the media control objects from session descriptions,
        instead offering APIs that would control each component directly. This
        was rejected based on a feeling that requiring exposure of this level
        of complexity to the application programmer would not be beneficial; it
        would result in an API where even a simple example would require a
        significant amount of code to orchestrate all the needed interactions,
        as well as creating a large API surface that needed to be agreed upon
        and documented. In addition, these API points could be called in any
        order, resulting in a more complex set of interactions with the media
        subsystem than the JSEP approach, which specifies how session
        descriptions are to be evaluated and applied.</t>

        <t>One variation on JSEP that was considered was to keep the basic
        session description-oriented API, but to move the mechanism for
        generating offers and answers out of the browser. Instead of providing
        createOffer/createAnswer methods within the browser, this approach would
        instead expose a getCapabilities API which would provide the application
        with the information it needed in order to generate its own session
        descriptions. This increases the amount of work that the application
        needs to do; it needs to know how to generate session descriptions from
        capabilities, and especially how to generate the correct answer from an
        arbitrary offer and the supported capabilities. While this could
        certainly be addressed by using a library like the one mentioned above,
        it basically forces the use of said library even for a simple example.
        Providing createOffer/createAnswer avoids this problem, but still allows
        applications to generate their own offers/answers (to a large extent) if
        they choose, using the description generated by createOffer as an
        indication of the browser's capabilities.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
        target="RFC2119"/>. </t>
    </section>

    <section title="Semantics and Syntax">
      <section title="Signaling Model">
        <t>JSEP does not specify a particular signaling model or state
        machine, other than the generic need to exchange SDP media
        descriptions in the fashion described by <xref
        target="RFC3264"/> (offer/answer) in order for both sides of the
        session to know how to conduct the session. JSEP provides mechanisms
        to create offers and answers, as well as to apply them to a session.
        However, the browser is totally decoupled from the actual mechanism by
        which these offers and answers are communicated to the remote side,
        including addressing, retransmission, forking, and glare handling.
        These issues are left entirely up to the application; the application
        has complete control over which offers and answers get handed to the
        browser, and when.</t>

        <figure anchor="fig-sigModel" title="JSEP Signaling Model">
          <artwork><![CDATA[
    +-----------+                               +-----------+ 
    |  Web App  |<--- App-Specific Signaling -->|  Web App  |
    +-----------+                               +-----------+
          ^                                            ^
          |  SDP                                       |  SDP 
          V                                            V
    +-----------+                                +-----------+ 
    |  Browser  |<----------- Media ------------>|  Browser  |
    +-----------+                                +-----------+
]]></artwork>
        </figure>
      </section>

      <section title="Session Descriptions and State Machine">
        <t>In order to establish the media plane, the user agent needs
        specific parameters to indicate what to transmit to the remote side,
        as well as how to handle the media that is received. These parameters
        are determined by the exchange of session descriptions in offers and
        answers, and there are certain details to this process that must be
        handled in the JSEP APIs.</t>

        <t>Whether a session description applies to the local side or the remote
        side affects the meaning of that description. For example, the list of
        codecs sent to a remote party indicates what the local side is willing
        to receive, which, when intersected with the set of codecs the remote
        side supports, specifies what the remote side should send.
        However, not all parameters follow this rule; for
        example, the SRTP parameters <xref target="RFC4568"/> sent to a remote
        party indicate what the local side will use to encrypt, and thereby what
        the remote party should expect to receive; the remote party will have to
        accept these parameters, with no option to choose a different value.</t>

        <t>In addition, various RFCs put different conditions on the format of
        offers versus answers. For example, a offer may propose multiple SRTP
        configurations, but an answer may only contain a single SRTP
        configuration.</t>

        <t>Lastly, while the exact media parameters are only known only after
        a offer and an answer have been exchanged, it is possible for the
        offerer to receive media after they have sent an offer and before they
        have received an answer. To properly process incoming media in this
        case, the offerer's media handler must be aware of the details of the
        offer before the answer arrives.</t>

        <t>Therefore, in order to handle session descriptions properly, the
        user agent needs: <list style="numbers">
            <t>To know if a session description pertains to the local or
            remote side.</t>

            <t>To know if a session description is an offer or an answer.</t>

            <t>To allow the offer to be specified independently of the
            answer.</t>
          </list> JSEP addresses this by adding both a setLocalDescription and
        a setRemoteDescription method and having session description objects
        contain a type field indicating the type of session description being
        supplied. This satisfies the requirements listed above for both the
        offerer, who first calls setLocalDescription(sdp [offer]) and then
        later setRemoteDescription(sdp [answer]), as well as for the answerer,
        who first calls setRemoteDescription(sdp [offer]) and then later
        setLocalDescription(sdp [answer]).</t>

        <t>JSEP also allows for an answer to be treated as provisional by the
        application. Provisional answers provide a way for an answerer to
        communicate initial session parameters back to the offerer, in order
        to allow the session to begin, while allowing a final answer to be
        specified later. This concept of a final answer is important to the
        offer/answer model; when such an answer is received, any extra
        resources allocated by the caller can be released, now that the exact
        session configuration is known. These "resources" can include things
        like extra ICE components, TURN candidates, or video decoders.
        Provisional answers, on the other hand, do no such deallocation
        results; as a result, multiple dissimilar provisional answers can be
        received and applied during call setup.</t>

        <t>In <xref target="RFC3264"/>, the constraint at the signaling level
        is that only one offer can be outstanding for a given session, but from
        the media stack level, a new offer can be generated at any point. For
        example, when using SIP for signaling, if one offer is sent, then
        cancelled using a SIP CANCEL, another offer can be generated even though
        no answer was received for the first offer. To support this, the JSEP
        media layer can provide an offer whenever the Javascript application
        needs one for the signaling. The answerer can send back zero or more
        provisional answers, and finally end the offer-answer exchange by
        sending a final answer. The state machine for this is as follows:</t>

        <t>
        <figure anchor="fig-state-machine" title="JSEP State Machine">
            <artwork><![CDATA[
                    setRemote(OFFER)               setLocal(PRANSWER)
                        /-----\                               /-----\
                        |     |                               |     |
                        v     |                               v     |
         +---------------+    |                +---------------+    |
         |               |----/                |               |----/
         |               | setLocal(PRANSWER)  |               |
         |  Remote-Offer |------------------- >| Local-Pranswer|
         |               |                     |               |
         |               |                     |               |
         +---------------+                     +---------------+    
              ^   |                                   |
              |   | setLocal(ANSWER)                  |
setRemote(OFFER)  |                                   |
              |   V                  setLocal(ANSWER) |
         +---------------+                            |
         |               |                            |
         |               |                            |
         |    Stable     |<---------------------------+
         |               |                            |
         |               |                            |
         +---------------+          setRemote(ANSWER) |                   
              ^   |                                   |
              |   | setLocal(OFFER)                   |
setRemote(ANSWER) |                                   |
              |   V                                   |
         +---------------+                     +---------------+
         |               |                     |               |
         |               | setRemote(PRANSWER) |               |
         |  Local-Offer  |------------------- >|Remote-Pranswer|
         |               |                     |               |
         |               |----\                |               |----\
         +---------------+    |                +---------------+    |
                        ^     |                               ^     |
                        |     |                               |     |
                        \-----/                               \-----/
                    setLocal(OFFER)               setRemote(PRANSWER)
]]></artwork>
          </figure>
        </t>

          <t> Aside from these state transitions, there is no other
        difference between the handling of provisional ("pranswer") and final
        ("answer") answers.</t>
      </section>

      <section title="Session Description Format">
        <t>In the WebRTC specification, session descriptions are formatted as
        SDP messages. While this format is not optimal for manipulation from
        Javascript, it is widely accepted, and frequently updated with new
        features. Any alternate encoding of session descriptions would have to
        keep pace with the changes to SDP, at least until the time that this
        new encoding eclipsed SDP in popularity. As a result, JSEP currently
        uses SDP as the internal representation for its session
        descriptions.</t>

        <t>However, to simplify Javascript processing, and provide for future
        flexibility, the SDP syntax is encapsulated within a
        SessionDescription object, which can be constructed from SDP, and be
        serialized out to SDP. If future specifications agree on a JSON format
        for session descriptions, we could easily enable this object to
        generate and consume that JSON.</t>

        <t>Other methods may be added to SessionDescription in the future to
        simplify handling of SessionDescriptions from Javascript. In the
        meantime, it would be simple to write a Javascript library to perform
        these manipulations.</t>
      </section>

      <section title="ICE">
        <t>When a new ICE candidate is available, the ICE Agent will notify
        the application via a callback; these candidates will automatically be
        added to the local session description. When all candidates have been
        gathered, the callback will also be invoked to signal that the
        gathering process is complete.</t>

        <section title="ICE Candidate Trickling">
          <t>Candidate trickling is a technique through which a caller may
          incrementally provide candidates to the callee after the initial
          offer has been dispatched; the semantics of "Trickle ICE" are
          defined in <xref target="I-D.ivov-mmusic-trickle-ice"></xref>.
          This process allows the callee to begin acting upon the call and
          setting up the ICE (and perhaps DTLS) connections immediately,
          without having to wait for the caller to gather all possible
          candidates. This results in faster call startup in cases where
          gathering is not performed prior to initating the call.</t>

          <t>JSEP supports optional candidate trickling by providing APIs that
          provide control and feedback on the ICE candidate gathering process.
          Applications that support candidate trickling can send the initial
          offer immediately and send individual candidates when they get the
          notified of a new candidate; applications that do not support this
          feature can simply wait for the indication that gathering is
          complete, and then create and send their offer, with all the
          candidates, at this time.</t>

          <t>Upon receipt of trickled candidates, the receiving application
          will supply them to its ICE Agent. This triggers the ICE Agent to
          start using the new remote candidates for connectivity checks.</t>

          <section title="ICE Candidate Format">
            <t>As with session descriptions, the syntax of the IceCandidate
            object provides some abstraction, but can be easily converted to
            and from the SDP candidate lines.</t>

            <t>The candidate lines are the only SDP information that is
            contained within IceCandidate, as they represent the only
            information needed that is not present in the initial offer (i.e.
            for trickle candidates). This information is carried with the same
            syntax as the "candidate-attribute" field defined for ICE.
            For example:</t>

            <figure>
              <artwork><![CDATA[
candidate:1 1 UDP 1694498815 192.0.2.33 10000 typ host
]]></artwork>
            </figure>

            <t>The IceCandidate object also contains fields to indicate which m=
            line it should be associated with. The m line can be identified in
            one of two ways; either by a m-line index, or a MID. The m-line
            index is a zero-based index, referring to the Nth m-line in the
            SDP. The MID uses the "media stream identification", as defined in
            <xref target="RFC5888"/> , to identify the m-line. WebRTC
            implementations creating an ICE Candidate object MUST populate both
            of these fields. Implementations receiving an ICE Candidate object
            SHOULD use the MID if they implement that functionality, or the
            m-line index, if not.</t>
          </section>
        </section>
      </section>

      <section title="Interactions With Forking">
        <t>Some call signaling systems allow various types of forking where an
        SDP Offer may be provided to more than one device. For example, SIP
        <xref target="RFC3261"/> defines both a "Parallel Search" and
        "Sequential Search".  Although these are primarily signaling level
        issues that are outside the scope of JSEP, they do have some impact on
        the configuration of the media plane which is relevant. When forking
        happens at the signaling layer, the Javascript application responsible
        for the signaling needs to make the decisions about what media should be
        sent or received at any point of time, as well as which remote endpoint
        it should communicate with; JSEP is used to make sure the media engine
        can make the RTP and media perform as required by the application. The
        basic operations that the applications can have the media engine do are:
        <list>
            <t>Start exchanging media to a given remote peer, but keep all the
            resources reserved in the offer.</t>

            <t>Start exchanging media with a given remote peer, and free any
            resources in the offer that are not being used.</t>
          </list></t>

        <section title="Sequential Forking">
          <t>Sequential forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, but only one
          active session ever exists at a time; no mixing of received media is
          performed.</t>

          <t>JSEP handles sequential forking well, allowing the application to
          easily control the policy for selecting the desired remote endpoint.
          When an answer arrives from one of the callees, the application can
          choose to apply it either as a provisional answer, leaving open the
          possibility of using a different answer in the future, or apply it
          as a final answer, ending the setup flow.</t>

          <t>In a "first-one-wins" situation, the first answer will be applied
          as a final answer, and the application will reject any subsequent
          answers. In SIP parlance, this would be ACK + BYE.</t>

          <t>In a "last-one-wins" situation, all answers would be applied as
          provisional answers, and any previous call leg will be terminated.
          At some point, the application will end the setup process, perhaps
          with a timer; at this point, the application could reapply the
          existing remote description as a final answer.</t>
        </section>

        <section title="Parallel Forking">
          <t>Parallel forking involves a call being dispatched to multiple
          remote callees, where each callee can accept the call, and multiple
          simultaneous active signaling sessions can be established as a
          result. If multiple callees send media at the same time, the
          possibilities for handling this are described in 
          Section 3.1 of <xref target="RFC3960"/>. 
          Most SIP devices today only support exchanging media with a
          single device at a time, and do not try to mix multiple early media
          audio sources, as that could result in a confusing situation. For
          example, consider having a European ringback tone mixed together
          with the North American ringback tone - the resulting sound would
          not be like either tone, and would confuse the user. If the
          signaling application wishes to only exchange media with one of the
          remote endpoints at a time, then from a media engine point of view,
          this is exactly like the sequential forking case.</t>

          <t>In the parallel forking case where the Javascript application
          wishes to simultaneously exchange media with multiple peers, the flow
          is slightly more complex, but the Javascript application can follow
          the strategy that <xref target="RFC3960"/> describes using UPDATE. (It
          is worth noting that use cases where this is the desired behavior are
          very unusual.) The UPDATE approach allows the signaling to set up a
          separate media flow for each peer that it wishes to exchange media
          with. In JSEP, this offer used in the UPDATE would be formed by simply
          creating a new PeerConnection and making sure that the same local
          media streams have been added into this new PeerConnection.  Then the
          new PeerConnection object would produce a SDP offer that could be used
          by the signaling to perform the UPDATE strategy discussed in <xref
          target="RFC3960"/>.</t>

          <t>As a result of sharing the media streams, the application will
          end up with N parallel PeerConnection sessions, each with a local
          and remote description and their own local and remote addresses. The
          media flow from these sessions can be managed by specifying SDP
          direction attributes in the descriptions, or the application can
          choose to play out the media from all sessions mixed together. Of
          course, if the application wants to only keep a single session, it
          can simply terminate the sessions that it no longer needs.</t>
        </section>
      </section>

      <section title="Session Rehydration">
        <t>In the event that the local application state is reinitialized,
        either due to a user reload of the page, or a decision within the
        application to reload itself (perhaps to update to a new version), it
        is possible to keep an existing session alive, via a process called
        "rehydration". The explicit goal of rehydration is to carry out this
        session resumption with no interaction with the remote side other than
        normal call signaling messages.</t>

        <t>With rehydration, the current signaling state is persisted
        somewhere outside of the page, perhaps on the application server, or
        in browser local storage. The page is then reloaded, the saved signaling
        state is retrieved, and a new PeerConnection object is created for the
        session. The previously obtained MediaStreams are re-acquired, and are
        given the same IDs as the original session; this ensures the IDs in use
        by the remote side continue to work. Next, a new offer is generated by
        the new PeerConnection; this offer will have new ICE and possibly new
        DTLS-SRTP certificate fingerprints (since the old ICE and SRTP state has
        been lost).
        Finally, this offer is used to re-initiate the session with the existing
        remote endpoint, who simply sees the new offer as an in-call
        renegotiation, and replies with an answer that can be supplied to
        setRemoteDescription. ICE processing proceeds as usual, and as soon as
        connectivity is established, the session will be back up and running
        again.</t>

        <t>[OPEN ISSUE: EKR proposed an alternative rehydration approach where
        the actual internal PeerConnection object in the browser was kept
        alive for some time after the web page was killed and provided some
        way for a new page to acquire the old PeerConnection object.]</t>
      </section>
    </section>

    <section title="Interface">
      <t>This section details the basic operations that must be present to
      implement JSEP functionality. The actual API exposed in the W3C API may
      have somewhat different syntax, but should map easily to these
      concepts.</t>

      <section title="SDP Requirements">

        <t>When generating SDP blobs, either for offers or answers, the
        generated SDP needs to conform to the following specifications.
        Similarly, in order to properly process received SDP blobs,
        implementations need to implement the functionality described in the
        following specifications. This list is derived from <xref
        target="I-D.ietf-rtcweb-rtp-usage"></xref>. <list style="format R-%d">
            <!-- TODO - fix the refs in here -->

            <t><xref target="RFC4566"/> is the base SDP specification and MUST
            be implemented.</t>

            <t>The <xref target="RFC5888"/> grouping framework MUST be
            implemented for signaling grouping information, and MUST be used
            to identify m= lines via the a=mid attribute.</t>

            <t><xref target="RFC5124"/> MUST be supported for signaling
            RTP/SAVPF RTP profile.</t>

            <t><xref target="RFC4585"/> MUST be implemented to signal RTCP based
            feedback.</t>

            <t><xref target="RFC5245"/> MUST be implemented for signaling the
            ICE candidate lines corresponding to each media stream.</t>

            <t><xref target="RFC5761"/> MUST be implemented to signal
            multiplexing of RTP and RTCP.</t>

            <t>The SDP atributes of "sendonly", "recvonly", "inactive", and
            "sendrecv" from <xref target="RFC4566"/> MUST be implemented to
            signal information about media direction.</t>

            <t><xref target="RFC5576"/> MUST be implemented to signal RTP SSRC
            values. [OPEN ISSUE; depends on BUNDLE and how we choose to
            represent multiple media sources]</t>

            <t><xref target="RFC5763"/> MUST be implemented to signal DTLS
            certificate fingerprints.</t>

            <t><xref target="RFC5506"/> MAY be implemented to signal
            Reduced-Size RTCP messages.</t>

            <t><xref target="RFC3556"/> with bandwidth modifiers MAY be
            supported for specifying RTCP bandwidth as a fraction of the media
            bandwidth, RTCP fraction allocated to the senders and setting
            maximum media bit-rate boundaries.</t>

            <t><xref target="RFC4568"/> MUST NOT be implemented to signal SDES SRTP
            keying information.</t>

            <t>A <xref target="I-D.ietf-mmusic-msid"/> MUST be supported, in order to signal associations
            between RTP objects and W3C MediaStreams and MediaStreamTracks in a
            standard way. </t>

            <t>The bundle mechanism in <xref target="I-D.ietf-mmusic-sdp-bundle-negotiation" /> 
            MUST be supported to signal the use or multiplexing
            RTP somethings on a single UDP port, in order to avoid excessive
            use of port number resources.  </t>

          </list></t>

        <t>As required by <xref target="RFC4566"/> Section 5.13 JSEP
        implementations MUST ignore unknown attributes (a=) lines.</t>

        <t>Example SDP for RTCWeb call flows can be found in <xref
        target="I-D.nandakumar-rtcweb-sdp"></xref>. [TODO: since we are starting
        to specify how to handle SDP in this document, should these call flows
        be merged into this document, or this link moved to the examples
        section?]</t>
      </section>

      <section title="Methods">
        <section title="createOffer">
          <t>The createOffer method generates a blob of SDP that contains a
          <xref target="RFC3264"/> offer with the supported configurations for
          the session, including descriptions of the local MediaStreams attached
          to this PeerConnection, the codec/RTP/RTCP options supported by this
          implementation, and any candidates that have been gathered by the ICE
          Agent. A constraints parameters may be supplied to provide additional
          control over the generated offer. This constraints parameter should
          allow for the following manipulations to be performed:
          <list style="symbols">
          <t>To indicate support for a media type even if no MediaStreamTracks
          of that type have been added to the session (e.g., an audio call that
          wants to receive video.)</t>
          <t>To trigger an ICE restart, for the purpose of reestablishing
          connectivity.</t>
          <t>For re-offer cases, to request an offer that contains the full set
          of supported capabilities, as opposed to just the currently negotiated
          parameters.</t>
          </list></t>

          <t>In the initial offer, the generated SDP will contain all desired
          functionality for the session (certain parts that are supported but
          not desired by default may be omitted); for each SDP line, the
          generation of the SDP must follow the process defined for generating
          an initial offer from the document (listed in Section 4.1) that
          specifies the given SDP line.</t>

          <t>In the event createOffer is called after the session is
          established, createOffer will generate an offer to
          modify the current session based on any changes that have been made
          to the session, e.g. adding or removing MediaStreams, or requesting
          an ICE restart. For each existing stream, the generation
          of each SDP line must follow the process defined for generating an
          updated offer from the document that specfies the given SDP line. For
          each new stream, the generation of the SDP must follow the process of
          generating an initial offer, as mentioned above.
          If no changes have been made, or for SDP lines that are unaffected by
          the requested changes, the offer will only contain the parameters
          negotiated by the last offer-answer exchange.</t>

          <t>Session descriptions generated by createOffer must be immediately
          usable by setLocalDescription; if a system has limited resources
          (e.g. a finite number of decoders), createOffer should return an
          offer that reflects the current state of the system, so that
          setLocalDescription will succeed when it attempts to acquire those
          resources. Because this method may need to inspect the system state
          to determine the currently available resources, it may be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not result in candidate gathering, or
          cause media to start or stop flowing.</t>
        </section>

        <section title="createAnswer">
          <t>The createAnswer method generates a blob of SDP that contains a
          <xref target="RFC3264"/> SDP answer with the supported configuration
          for the session that is compatible with the parameters supplied in the
          offer. Like createOffer, the returned blob contains descriptions of
          the local MediaStreams attached to this PeerConnection, the
          codec/RTP/RTCP options negotiated for this session, and any candidates
          that have been gathered by the ICE Agent. A constraints parameter may
          be supplied to provide additional control over the generated
          answer.</t>

          <t>As an answer, the generated SDP will contain a specific
          configuration that specifies how the media plane should be
          established; for each SDP line, the generation of the SDP must follow
          the process defined for generating an answer from the document that
          specifies the given SDP line.</t>

          <t>Session descriptions generated by createAnswer must be
          immediately usable by setLocalDescription; like createOffer, the
          returned description should reflect the current state of the system.
          Because this method may need to inspect the system state to
          determine the currently available resources, it may need to be
          implemented as an async operation.</t>

          <t>Calling this method may do things such as generate new ICE
          credentials, but does not trigger candidate gathering or change media
          state.</t>
        </section>

        <section title="SessionDescriptionType">
          <t>Session description objects (RTCSessionDescription) may be of
          type "offer", "pranswer", and "answer". These types provide
          information as to how the description parameter should be parsed,
          and how the media state should be changed.</t>

          <t>"offer" indicates that a description should be parsed as an
          offer; said description may include many possible media
          configurations. A description used as an "offer" may be applied
          anytime the PeerConnection is in a stable state, or as an update to
          a previously supplied but unanswered "offer".</t>

          <t>"pranswer" indicates that a description should be parsed as an
          answer, but not a final answer, and so should not result in the
          freeing of allocated resources. It may result in the start of media
          transmission, if the answer does not specify an inactive media
          direction. A description used as a "pranswer" may be applied as a
          response to an "offer", or an update to a previously sent
          "answer".</t>

          <t>"answer" indicates that a description should be parsed as an
          answer, the offer-answer exchange should be considered complete, and
          any resources (decoders, candidates) that are no longer needed can
          be released. A description used as an "answer" may be applied as a
          response to a "offer", or an update to a previously sent
          "pranswer".</t>

          <t>The only difference between a provisional and final answer is that
          the final answer results in the freeing of any unused resources that
          were allocated as a result of the offer. As such, the application can
          use some discretion on whether an answer should be applied as
          provisional or final, and can change the type of the session
          description as needed. For example, in a serial forking scenario, an
          application may receive multiple "final" answers, one from each remote
          endpoint. The application could choose to accept
          the initial answers as provisional answers, and only apply an answer
          as final when it receives one that meets its criteria (e.g. a live
          user instead of voicemail).</t>

          <section title="Use of Provisional Answers">
            <t>Most web applications will not need to create answers using the
            "pranswer" type. The preferred handling for a web application
            would be to create and send an "inactive" answer more or less
            immediately after receiving the offer, instead of waiting for a
            human user to physically answer the call. Later, when the human
            input is received, the application can create a new "sendrecv" offer
            to update the previous offer/answer pair and start the media flow.
            This approach is preferred because it minimizes the amount of time
            that the offer-answer exchange is left open, in addition to avoiding
            media clipping by ensuring the transport is ready to go by the time
            the call is phyiscally answered. However, some applications may not
            be able to do this, particularly ones that are attempting to gateway
            to other signaling protocols. In these cases, "pranswer" can still
            allow the application to warm up the transport.</t>

            <t>Consider a typical web application that will set up a data
            channel, an audio channel, and a video channel. When an endpoint
            receives an offer with these channels, it could send an answer
            accepting the data channel for two-way data, and accepting the
            audio and video tracks as inactive or receive-only. It could then
            ask the user to accept the call, acquire the local media streams,
            and send a new offer to the remote side moving the audio and video
            to be two-way media. By the time the human has accepted the call and
            sent the new offer, it is likely that the ICE and DTLS handshaking
            for all the channels will already be set up.
            </t>
          </section>

          <section title="Rollback">
            <t>In certain situations it may be desirable to "undo" a change made
            to setLocalDescription or setRemoteDescription. Consider a case
            where a call is ongoing, and one side wants to change some of the
            session parameters; that side generates an updated offer and then
            calls setLocalDescription. However, the remote side, either before
            or after setRemoteDescription, decides it does not want to accept
            the new parameters, and sends a reject message back to the offerer.
            Now, the offerer, and possibly the answerer as well, need to return
            to a stable state and the previous local/remote description. To
            support this, we introduce the concept of "rollback".</t>

            <t>A rollback returns the state machine to its previous state, and
            the local or remote description to its previous value. Any resources
            or candidates that were allocated by the new local description are
            discarded; any media that is received will be processed according
            to the previous session description.
            </t>

            <t>A rollback is performed by supplying a session description of
            type "rollback" to either setLocalDescription or
            setRemoteDescription, depending on which needs to be rolled back
            (i.e. if the new offer was supplied to setLocalDescription, the
            rollback should be done on setLocalDescription as well.)</t>
          </section>
        </section>

        <section title="setLocalDescription">
          <t>The setLocalDescription method instructs the PeerConnection to
          apply the supplied SDP blob as its local configuration. The type
          field indicates whether the blob should be processed as an offer,
          provisional answer, or final answer; offers and answers are checked
          differently, using the various rules that exist for each SDP
          line.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for receiving and decoding media. In order
          to successfully handle scenarios where the application wants to
          offer to change from one media format to a different, incompatible
          format, the PeerConnection must be able to simultaneously support
          use of both the old and new local descriptions (e.g. support codecs
          that exist in both descriptions) until a final answer is received,
          at which point the PeerConnection can fully adopt the new local
          description, or roll back to the old description if the remote side
          denied the change.</t>

          <t>This API indirectly controls the candidate gathering process. When
          a local description is supplied, and the number of transports
          currently in use does not match the number of transports needed by the
          local description, the PeerConnection will create transports as needed
          and begin gathering candidates for them.</t>

          <t>If setRemoteDescription was previous called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, and media are available to
          send, this will result in the starting of media transmission.</t>
        </section>

        <section title="setRemoteDescription">
          <t>The setRemoteDescription method instructs the PeerConnection to
          apply the supplied SDP blob as the desired remote configuration. As
          in setLocalDescription, the type field of the indicates how the blob
          should be processed.</t>

          <t>This API changes the local media state; among other things, it
          sets up local resources for sending and encoding media.</t>

          <t>If setRemoteDescription was previously called with an offer, and
          setLocalDescription is called with an answer (provisional or final),
          and the media directions are compatible, and media are available to
          send, this will result in the starting of media transmission.</t>
        </section>

        <section title="localDescription">
          <t>The localDescription method returns a copy of the current local
          configuration, i.e. what was most recently passed to
          setLocalDescription, plus any local candidates that have been
          generated by the ICE Agent.</t>

          <t>TODO: Do we need to expose accessors for both the current and
          proposed local description?</t>

          <t>A null object will be returned if the local description has not
          yet been established, or if the PeerConnection has been closed.</t>
        </section>

        <section title="remoteDescription">
          <t>The remoteDescription method returns a copy of the current remote
          configuration, i.e. what was most recently passed to
          setRemoteDescription, plus any remote candidates that have been
          supplied via processIceMessage.</t>

          <t>TODO: Do we need to expose accessors for both the current and
          proposed remote description?</t>

          <t>A null object will be returned if the remote description has not
          yet been established, or if the PeerConnection has been closed.</t>
        </section>

        <section title="updateIce">
          <t>The updateIce method allows the configuration of the ICE Agent to
          be changed during the session, primarily for changing which types of
          local candidates are provided to the application and used for
          connectivity checks. A callee may initially configure the ICE Agent
          to use only relay candidates, to avoid leaking location information,
          but update this configuration to use all candidates once the call is
          accepted.</t>

          <t>Regardless of the configuration, the gathering process collects
          all available candidates, but excluded candidates will not be
          surfaced in onicecandidate callback or used for connectivity
          checks.</t>

          <t>This call may result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>

        <section title="addIceCandidate">
          <t>The addIceCandidate method provides a remote candidate to the ICE
          Agent, which, if parsed successfully, will be added to the remote
          description according to the rules defined for Trickle ICE.
          Connectivity checks will be sent to the new candidate.
          </t>

          <t>This call will result in a change to the state of the ICE Agent,
          and may result in a change to media state if it results in
          connectivity being established.</t>
        </section>
      </section>
    </section>

    <section title="SDP Interaction Procedures">
      <t>This section describes the specific procedures to be followed when
         creating and parsing SDP objects.
      </t>

      <section title="Constructing an Offer">
          <t>When createOffer is called, a new SDP description must be created that includes the functionality specified in <xref
        target="I-D.ietf-rtcweb-rtp-usage"/>. The exact details of this process are explained below.</t>

        <section title="Initial Offers">
          <t>When createOffer is called for the first time, the result is known as the initial offer.</t>

          <t>The first step in generating an initial offer is to generate session-level
            attributes, as specified in <xref target="RFC4566" />, Section 5. Specifically:
            <list style="symbols">
                <t>The first SDP line MUST be "v=0", as specified in <xref target="RFC4566" />, Section 5.1</t>
                <t>The second SDP line MUST be an "o=" line, as specified in <xref target="RFC4566" />, Section 5.2.
                   The value of the &lt;username&gt; field SHOULD be "-".
                   The value of the &lt;sess-id&gt; field SHOULD be a cryptographically random number. To ensure uniqueness, this number SHOULD be at least 64 bits long.
                   The value of the &lt;sess-version&gt; field SHOULD be zero.
                   The value of the &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; tuple 
                   SHOULD be set to a non-meaningful address, such as IN IP4 0.0.0.0,
                   to prevent leaking the local address in this field. As mentioned in <xref target="RFC4566" />, the entire
                   o= line needs to be unique, but selecting a random number for &lt;sess-id&gt; is sufficient
                   to accomplish this.</t>
                <t>The third SDP line MUST be a "s=" line, as specified in <xref target="RFC4566" />, Section 5.3; a single space SHOULD be used as the session name, e.g. "s= "</t>
                <t>Session Information ("i="), URI ("u="), Email Address ("e="), Phone Number ("p="), Bandwidth ("b="), Repeat Times ("r="), and Time Zones ("z=") lines are not useful in this context and SHOULD NOT be included.</t>
                <t>Encryption Keys ("k=") lines do not provide sufficient security and MUST NOT be included.</t>
                <t>A "t=" line MUST be added, as specified in <xref target="RFC4566" />, Section 5.9; both &lt;start-time&gt; and &lt;stop-time&gt; SHOULD be set to zero, e.g. "t=0 0".</t> 
                <t>An "a=group" attribute MUST be added, as specified in <xref target="RFC5888" />, with semantics of "BUNDLE" and identifying the m= sections to be bundled.</t>
            </list>
        </t>
        <t>The next step is to generate m= sections for each MediaStreamTrack that has been added to the PeerConnection via the addStream method. Note that this method takes a MediaStream, which can contain multiple MediaStreamTracks, and therefore multiple m= sections can be generated even if addStream is only called once.</t>

        <t>Each m= section should be generated as specified in <xref target="RFC4566" />, Section 5.14. The &lt;proto&gt; field MUST be set to "RTP/SAVPF". Each m= section MUST include the following:
            <list style="symbols">
                <t>An "a=mid" line, as specified in <xref target="RFC5888" />, Section 4.</t>
                <t>An "a=msid" line, as specified in <xref target="I-D.ietf-mmusic-msid" />, Section 2.</t>
                <t>[OPEN ISSUE: Use of App Token versus stream-correlator]</t>
                <t>An "a=sendrecv" line, as specified in <xref target="RFC3264" />, Section 5.1.</t>
                <t>For each supported codec, "a=rtpmap" and "a=fmtp" lines, as specified in <xref target="RFC4566" />, Section 6. For audio, the codecs specified in <xref target="I-D.ietf-rtcweb-audio"/>, Section 3, MUST be be supported.</t>
                <t>For each primary codec where RTP retransmission should be used, a corresponding "a=rtpmap" line indicating "rtx/8000" and an "a=fmtp" line that references the payload type fo the primary codec, as specified in <xref target="RFC4588" />.</t>
                <t>For each supported FEC mechanism, a corresponding "a=rtpmap" line indicating the desired FEC codec.</t>
                <t>"a=ice-ufrag" and "a=ice-passwd" lines, as specified in <xref target="RFC5245" />, Section 15.4.</t>
                <t>An "a=ice-options" line, with the "trickle" option, as specified in <xref target="I-D.ivov-mmusic-trickle-ice" />, Section 4.</t>
                <t>For each candidate that has been gathered during the most recent gathering phase, an "a=candidate" line, as specified in <xref target="RFC5245" />, Section 4.3., paragraph 3.</t>
                <t>For the current default candidate, a "c=" line, as specific in <xref target="RFC5245" />, Section 4.3., paragraph 6.</t>
                <t>An "a=fingerprint" line, as specified in <xref target="RFC4572" />, Section 5. Use of the SHA-256 algorithm for the fingerprint is REQUIRED; if the browser also supports stronger hashes, additional "a=fingerprint" lines with these hashes MAY also be added.</t>
                <t>An "a=setup" line, as specified in <xref target="RFC4145" />, Section 4, and clarified for use in DTLS-SRTP secnarios in <xref target="RFC5763" />, Section 5. The role value in the offer MUST be "actpass".</t>
                <t>An "a=rtcp-mux" line, as specified in <xref target="RFC5761" />, Section 5.1.1.</t>
                <t>An "a=rtcp-rsize" line, as specified in <xref target="RFC5506" />, Section 5.</t>
                <t>For each supported RTP header extension, an "a=extmap" line, as specified in <xref target="RFC5285" />, Section 5. The list of header extensions that SHOULD/MUST be supported is specified in <xref target="I-D.ietf-rtcweb-rtp-usage"/>, Section 5.2. Any header extensions that require encryption MUST be specified as indicated in <xref target="RFC6904" />, Section 4.</t>
                <t>For each supported RTCP feedback mechanism, an "a=rtcp-fb" mechanism, as specified in <xref target="RFC4585" />, Section 4.2. The list of RTCP feedback mechanisms that SHOULD/MUST be supported is specified in <xref target="I-D.ietf-rtcweb-rtp-usage"/>, Section 5.1.</t>
                <t>An "a=ssrc" line, as specified in <xref target="RFC5576" />, Section 4.1, indicating the SSRC to be used for sending media.</t>
                <t>If RTX is supported for this media type, another "a=ssrc" line with the RTX SSRC, and an "a=ssrc-group" line, as specified in <xref target="RFC5576" />, section 4.2, with semantics set to "FID" and including the primary and RTX SSRCs.</t>
                <t>If FEC is supported for this media type, another "a=ssrc" line with the FEC SSRC, and an "a=ssrc-group" line, as specified in <xref target="RFC5576" />, section 4.2, with semantics set to "FEC" and including the primary and FEC SSRCs.</t>
                <t>[OPEN ISSUE: Handling of a=imageattr]</t>
                <t>[TODO: bundle-only]</t>
            </list>
        </t>

        <t>Lastly, if a data channel has been created, a m= section must be generated for data. The &lt;media&gt; field MUST be set to "application" and the &lt;proto&gt; field must be set to "DTLS/SCTP", as specified in <xref target="I-D.ietf-mmusic-sctp-sdp" />, Section 3. The "a=mid", "a=ice-ufrag", "a=ice-passwd", "a=ice-options", "a=candidate", "a=fingerprint", and "a=setup" lines must be included as mentioned above.
        [OPEN ISSUE: additional SCTP-specific stuff to be included, as indicated in <xref target="I-D.jesup-rtcweb-data-protocol" /> (currently none)]
        </t>

        <t>Attributes that are common between all m= sections MAY be moved to session-level, if desired.</t>

        <t>Attributes other than the ones specified above MAY be included, except for the following attributes which are specifically incompatible with the requirements of <xref
        target="I-D.ietf-rtcweb-rtp-usage"/>, and MUST NOT be included:
          <list style="symbols">
            <t>"a=crypto"</t>
            <t>"a=key-mgmt"</t>
            <t>"a=ice-lite"</t>
          </list>
        </t>
    </section>

    <section title="Subsequent Offers">
        <t>When createOffer is called a second (or later) time, the processing is different, depending on the current signaling state.</t>
        <t>If the initial offer was not applied using setLocalDescription, meaning the PeerConnection is still in the "stable" state, the steps for generating an initial offer should be followed, with this exception:
            <list style="symbols">
            <t>The "o=" line MUST stay the same.</t>
            </list>
        </t>
        <t>If the initial offer was applied using setLocalDescription, but an answer from the remote side has not yet been applied, meaning the PeerConnection is still in the "sent-offer" state, the steps for generating an initial offer should be followed, with these exceptions:
          <list style="symbols">
            <t>The "o=" line MUST stay the same, except for the &lt;session-version&gt; field, which MUST increase by 1 from the previously applied local description.</t>
            <t>The "s=" and "t=" lines MUST stay the same.</t>
            <t>Each "a=mid" line MUST stay the same.</t>
            <t>Each "a=ice-ufrag" and "a=ice-pwd" line MUST stay the same.</t>
            <t>For MediaStreamTracks that are still present, the "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST stay the same.</t>
            <t>If any MediaStreamTracks have been removed, either through the removeStream method or by removing them from an added MediaStream, their m= sections MUST be marked as recvonly by changing the value of the <xref target="RFC3264" /> directional attribute to "a=recvonly". The "a=msid", "a=ssrc", and "a=ssrc-group" lines MUST be removed from the associated m= sections.</t>
          </list>
      </t>
      <t>If the initial offer was applied using setLocalDescription, and an answer from the remote side has been applied using setRemoteDescription, meaning the PeerConnection is in the "received-pranswer" or "stable" states, an offer is generated based on the negotiated session descriptions by following the steps mentioned for the "sent-offer" state above, along with these exceptions: 
          <list style="symbols">
            <t>If a m= section was rejected, i.e. has had its port set to zero in either the local or remote description, it MUST remain rejected and have a zero port in the new offer, as indicated in RFC3264, Section 5.1.</t>
            <t>If a m= section exists in the current local description, but has its state set to inactive or recvonly, and a new MediaStreamTrack is added, the previously existing m= section MUST be recycled instead of creating a new m= section. [OPEN ISSUE: Nail down exactly what this means. Should the codecs remain the same? (No.) Should ICE restart? (No.) Can the "a=mid" attribute be changed? (Yes?)]</t>
            <t>If a m= section exists in the current local description, but does not have an associated MediaStreamTrack (i.e. it is inactive or recvonly), a corresponding m= section MUST be generated in the new offer, but without "a=msid", "a=ssrc", or "a=ssrc-group" attributes, and the appropriate directional attribute must be specified.</t>
          </list>
      </t>
      <t>In addition, for each previously existing, non-rejected m= section in the new offer, the following adjustments are made based on the contents of the corresponding m= section in the current remote description:
        <list style="symbols">
            <t>The m= line and corresponding "a=rtpmap" and "a=fmtp" lines MUST only include codecs present in the remote description.</t>
            <t>The RTP header extensions MUST only include those that are present in the remote description.</t>
            <t>The RTCP feedback extensions MUST only include those that are present in the remote description.</t>
            <t>The "a=rtcp-mux" line MUST only be added if present in the remote description.</t>
            <t>The "a=rtcp-rsize" line MUST only be added if present in the remote description.</t>
        </list>
    </t>
    </section>

        <section title="Constraints Handling">
        <t>The createOffer method takes as a parameter a MediaConstraints object. Special processing is performed when generating a SDP description if the following constraints are present.</t>
        <section title="OfferToReceiveAudio">
            <t>If the "OfferToReceiveAudio" constraint is specified, with a value of "true", the offer MUST include a non-rejected m= section with media type "audio", even if no audio MediaStreamTrack has been added to the PeerConnection. This allows the offerer to receive audio even when not sending it; accordingly, the directional attribute on the audio m= section MUST be set to recvonly. If this constraint is specifed when an audio MediaStreamTrack has already been added to the PeerConnection, or a non-rejected m= section with media type "audio" previously existed, it has no effect.</t>
        </section>
        <section title="OfferToReceiveVideo">
            <t>If the "OfferToReceiveAudio" constraint is specified, with a value of "true", the offer MUST include a m= section with media type "video", even if no video MediaStreamTrack has been added to the PeerConnection. This allows the offerer to receive video even when not sending it; accordingly, the directional attribute on the video m= section MUST be set to recvonly. If this constraint is specifed when an video MediaStreamTrack has already been added to the PeerConnection, or a non-rejected m= section with media type "video" previously existed, it has no effect.</t>
        </section>
        <section title="VoiceActivityDetection">
            <t>If the "VoiceActivityDetection" constraint is specified, with a value of "true", the offer MUST indicate support for silence suppression by including comfort noise ("CN") codecs for each supported clockrate, as specified in <xref target="RFC3389" />, Section 5.1. [OPEN issue: should this do anything in signaling, or should it just control built-in DTX modes in audio codecs? Opus has built-in DTX, but G.711 does not.]</t>
        </section>
        <section title="IceRestart">
            <t>If the "IceRestart" constraint is specified, with a value of "true", the offer MUST indicate an ICE restart by generating new ICE ufrag and pwd attributes, as specified in RFC5245, Section 9.1.1.1. If this constraint is specified on an initial offer, it has no effect (since a new ICE ufrag and pwd are already generated).</t>
        </section>
      </section>
      </section>

      <section title="Generating an Answer">
           <t>When createAnswer is called, a new SDP description must be created that is compatible with the supplied remote description as well as the requirements specified in <xref
        target="I-D.ietf-rtcweb-rtp-usage"/>. The exact details of this process are explained below.</t>

        <section title="Initial Answers">
          <t>When createAnswer is called for the first time, the result is known as the initial answer.</t>

          <t>The first step in generating an initial answer is to generate session-level attributes. The process here is identical to that indicated in the Initial Offers section above.</t>
        </section> 
        <section title="Subsequent Answers">
        </section>
        <section title="Constraints Handling">
        </section>
      </section>

      <section title="Parsing an Offer">
      </section>

      <section title="Parsing an Answer">
      </section>

      <section title="Applying a Local Description">
      </section>

      <section title="Applying a Remote Description">
      </section>
    </section>
 
    <section title="Configurable SDP Parameters">
      <t>Note: This section is still very early and is likely to significantly
      change as we get a better understanding of a) the use cases for this
      b) the implications at the protocol level c) feedback from implementors
      on what they can do.</t>

      <t>The following elements of the SDP media description MUST NOT be
      changed between the createOffer and the setLocalDescription, since they
      reflect transport attributes that are solely under browser control, and
      the browser MUST NOT honor an attempt to change them:</t>

      <t><list style="symbols">
          <t>The number, type and port number of m-lines.</t>
          <t>The generated ICE credentials (a=ice-ufrag and a=ice-pwd).</t>
          <t>The set of ICE candidates and their parameters (a=candidate).</t>
      </list></t>

      <t>The following modifications, if done by the browser to a description
      between createOffer/createAnswer and the setLocalDescription, MUST be
      honored by the browser:</t>

      <t><list style="symbols">
          <t>Remove or reorder codecs (m=)</t>
      </list></t>

      <t>The following parameters may be controlled by constraints passed into
      createOffer/createAnswer. As an open issue, these changes may also be
      be performed by manipulating the SDP returned from
      createOffer/createAnswer, as indicated above, as long as the capabilities
      of the endpoint are not exceeded (e.g. asking for a resolution greater
      than what the endpoint can encode):</t>

      <t><list style="symbols">
          <t>disable BUNDLE (a=group)</t>

          <t>disable RTCP mux (a=rtcp-mux)</t>

          <t>change send resolution or framerate</t>

          <t>change desired recv resolution or framerate</t>

          <t>change maximum total bandwidth (b=)
          [OPEN ISSUE: need to clarify if this is CT or AS - see section 5.8 of
           <xref target="RFC4566" />]</t>

          <t>remove desired AVPF mechanisms (a=rtcp-fb)</t>

          <t>remove RTP header extensions (a=extmap)</t>

          <t>change media send/recv state (a=sendonly/recvonly/inactive)</t>
      </list></t>

      <t>For example, an application could implement call hold by adding an
      a=inactive attribute to its local description, and then applying and
	    signaling that description.</t>

      <t>The application can also modify the SDP to reduce the capabilities in
      the offer it sends to the far side in any way the application sees fit,
      as long as it is a valid SDP offer and specifies a subset of what the
      browser is expecting to do.</t>

      <t>As always, the application is solely responsible for what it
      sends to the other party, and all incoming SDP will be processed by the
      browser to the extent of its capabilities. It is an error to assume that
      all SDP is well-formed; however, one should be able to assume that any
      implementation of this specification will be able to process, as a remote
      offer or answer, unmodified SDP coming from any other implementation of
      this specification. </t>

    </section>

    <section title="Security Considerations">

      <t>The intent of the WebRTC protocol suite is to provide an environment
      that is securable by default: all media is encrypted, keys are exchanged
      in a secure fashion, and the Javascript API includes functions that can
      be used to verify the identity of communication partners.</t>

    </section>

    <section title="IANA Considerations">
      <t>This document requires no actions from IANA.</t>
    </section>

    <section title="Acknowledgements">

      <t> Significant text incorporated in the draft as well and review was
      provided by Harald Alvestrand and Suhas Nandakumar.  <!-- ACK 1 --> Dan
      Burnett, Neil Stratford, Eric Rescorla, Anant Narayanan, Andrew Hutton,
      Richard Ejzak, <!-- ACK 2 -->
      <!-- ACK 3 --> <!-- ACK 4 --> and Adam Bergkvist all provided valuable
      feedback on this proposal. <!-- ACK 5 --> <!-- ACK 5a --> <!-- ACK 5b -->
      <!-- ACK 5c --> Matthew Kaufman provided the observation that keeping
      state out of the browser allows a call to continue even if the page is
      reloaded. <!-- ACK 6 --> <!-- ACK 7 --></t>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <!-- NORM 1 -->

      <reference anchor="RFC5245">
        <front>
          <title>Interactive Connectivity Establishment (ICE): A Protocol for
          Network Address Translator (NAT) Traversal for Offer/Answer
          Protocols</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <date month="April" year="2010" />
        </front>

        <seriesInfo name="RFC" value="5245" />

        <format octets="285120"
                target="http://www.rfc-editor.org/rfc/rfc5245.txt" type="TXT" />
      </reference>



<reference anchor='RFC5888'>

<front>
<title>The Session Description Protocol (SDP) Grouping Framework</title>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<date year='2010' month='June' />
<abstract>
<t>In this specification, we define a framework to group "m" lines in the Session Description Protocol (SDP) for different purposes.  This framework uses the "group" and "mid" SDP attributes, both of which are defined in this specification.  Additionally, we specify how to use the framework for two different purposes: for lip synchronization and for receiving a media flow consisting of several media streams on different transport addresses.  This document obsoletes RFC 3388. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5888' />
<format type='TXT' octets='43924' target='http://www.rfc-editor.org/rfc/rfc5888.txt' />
</reference>


<reference anchor='RFC5761'>

<front>
<title>Multiplexing RTP Data and Control Packets on a Single Port</title>
<author initials='C.' surname='Perkins' fullname='C. Perkins'>
<organization /></author>
<author initials='M.' surname='Westerlund' fullname='M. Westerlund'>
<organization /></author>
<date year='2010' month='April' />
<abstract>
<t>This memo discusses issues that arise when multiplexing RTP data packets and RTP Control Protocol (RTCP) packets on a single UDP port.  It updates RFC 3550 and RFC 3551 to describe when such multiplexing is and is not appropriate, and it explains how the Session Description Protocol (SDP) can be used to signal multiplexed sessions. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5761' />
<format type='TXT' octets='31778' target='http://www.rfc-editor.org/rfc/rfc5761.txt' />
</reference>

<reference anchor='RFC4585'>

<front>
<title>Extended RTP Profile for Real-time Transport Control Protocol
(RTCP)-Based Feedback (RTP/AVPF)</title>
<author initials='J.' surname='Ott' fullname='J. Ott'>
<organization /></author>
<author initials='S.' surname='Wenger' fullname='S. Wenger'>
<organization /></author>
<author initials='N.' surname='Sato' fullname='N. Sato'>
<organization /></author>
<author initials='C.' surname='Burmeister' fullname='C. Burmeister'>
<organization /></author>
<author initials='J.' surname='Rey' fullname='J. Rey'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>Real-time media streams that use RTP are, to some degree, resilient against
packet losses.  Receivers may use the base mechanisms of the Real-time Transport
Control Protocol (RTCP) to report packet reception statistics and thus allow a
sender to adapt its transmission behavior in the mid-term.  This is the sole
means for feedback and feedback-based error repair (besides a few codec-specific
mechanisms).  This document defines an extension to the Audio-visual Profile
(AVP) that enables receivers to provide, statistically, more immediate feedback
to the senders and thus allows for short-term adaptation and efficient
feedback-based repair mechanisms to be implemented.  This early feedback profile
(AVPF) maintains the AVP bandwidth constraints for RTCP and preserves
scalability to large groups. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4585' />
<format type='TXT' octets='117762' target='http://www.rfc-editor.org/rfc/rfc4585.txt' />
</reference>


<reference anchor='RFC5124'>

<front>
<title>Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)</title>
<author initials='J.' surname='Ott' fullname='J. Ott'>
<organization /></author>
<author initials='E.' surname='Carrara' fullname='E. Carrara'>
<organization /></author>
<date year='2008' month='February' />
<abstract>
<t>An RTP profile (SAVP) for secure real-time communications and another profile
(AVPF) to provide timely feedback from the receivers to a sender are defined in
RFC 3711 and RFC 4585, respectively.  This memo specifies the combination of
both profiles to enable secure RTP communications with
feedback. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5124' />
<format type='TXT' octets='37856' target='http://www.rfc-editor.org/rfc/rfc5124.txt' />
</reference>


<reference anchor='RFC3261'>

<front>
<title>SIP: Session Initiation Protocol</title>
<author initials='J.' surname='Rosenberg' fullname='J. Rosenberg'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='A.' surname='Johnston' fullname='A. Johnston'>
<organization /></author>
<author initials='J.' surname='Peterson' fullname='J. Peterson'>
<organization /></author>
<author initials='R.' surname='Sparks' fullname='R. Sparks'>
<organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'>
<organization /></author>
<author initials='E.' surname='Schooler' fullname='E. Schooler'>
<organization /></author>
<date year='2002' month='June' />
<abstract>
<t>This document describes Session Initiation Protocol (SIP), an
application-layer control (signaling) protocol for creating, modifying, and
terminating sessions with one or more participants.  These sessions include
Internet telephone calls, multimedia distribution, and multimedia
conferences. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3261' />
<format type='TXT' octets='647976' target='http://www.rfc-editor.org/rfc/rfc3261.txt' />
</reference>


      <!-- NORM 2 -->


<reference anchor='I-D.ietf-rtcweb-audio'>
<front>
<title>WebRTC Audio Codec and Processing Requirements</title>

<author initials='J' surname='Valin' fullname='Jean-Marc Valin'>
    <organization />
</author>

<author initials='C' surname='Bran' fullname='Cary Bran'>
    <organization />
</author>

<date month='August' day='2' year='2013' />

<abstract><t>This document outlines the audio codec and processing requirements for WebRTC client application and endpoint devices.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-audio-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-audio-02.txt' />
</reference>


      <!-- NORM 3 -->

<reference anchor='I-D.ietf-mmusic-sctp-sdp'>
<front>
<title>Stream Control Transmission Protocol (SCTP)-Based Media Transport in the Session Description Protocol (SDP)</title>

<author initials='S' surname='Loreto' fullname='Salvatore Loreto'>
    <organization />
</author>

<author initials='G' surname='Camarillo' fullname='Gonzalo Camarillo'>
    <organization />
</author>

<date month='June' day='30' year='2013' />

<abstract><t>SCTP (Stream Control Transmission Protocol) is a transport protocol used to establish associations between two endpoints.  This document describes how to express media transport over SCTP in SDP (Session Description Protocol).  This document defines the 'SCTP', 'SCTP/DTLS' and 'DTLS/SCTP' protocol identifiers for SDP.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-sctp-sdp-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sctp-sdp-04.txt' />
</reference>


      <!-- NORM 4 -->


<reference anchor='RFC4572'>

<front>
<title>Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)</title>
<author initials='J.' surname='Lennox' fullname='J. Lennox'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>This document specifies how to establish secure connection-oriented media transport sessions over the Transport Layer Security (TLS) protocol using the Session Description Protocol (SDP). It defines a new SDP protocol identifier, 'TCP/TLS'. It also defines the syntax and semantics for an SDP 'fingerprint' attribute that identifies the certificate that will be presented for the TLS session. This mechanism allows media transport over TLS connections to be established securely, so long as the integrity of session descriptions is assured.&lt;/t>&lt;t> This document extends and updates RFC 4145. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4572' />
<format type='TXT' octets='38658' target='http://www.rfc-editor.org/rfc/rfc4572.txt' />
</reference>

      <!-- NORM 5 -->


<reference anchor='RFC4145'>

<front>
<title>TCP-Based Media Transport in the Session Description Protocol (SDP)</title>
<author initials='D.' surname='Yon' fullname='D. Yon'>
<organization /></author>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<date year='2005' month='September' />
<abstract>
<t>This document describes how to express media transport over TCP using the Session Description Protocol (SDP).  It defines the SDP 'TCP' protocol identifier, the SDP 'setup' attribute, which describes the connection setup procedure, and the SDP 'connection' attribute, which handles connection reestablishment. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4145' />
<format type='TXT' octets='30225' target='http://www.rfc-editor.org/rfc/rfc4145.txt' />
</reference>


      <!-- NORM 6 -->

      <!-- NORM 7 -->

      <!-- NORM 8 -->

      <!-- NORM 9 -->

      <!-- NORM 10 -->


<reference anchor='RFC5285'>

<front>
<title>A General Mechanism for RTP Header Extensions</title>
<author initials='D.' surname='Singer' fullname='D. Singer'>
<organization /></author>
<author initials='H.' surname='Desineni' fullname='H. Desineni'>
<organization /></author>
<date year='2008' month='July' />
<abstract>
<t>This document provides a general mechanism to use the header extension feature of RTP (the Real-Time Transport Protocol).  It provides the option to use a small number of small extensions in each RTP packet, where the universe of possible extensions is large and registration is de-centralized.  The actual extensions in use in a session are signaled in the setup information for that session. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5285' />
<format type='TXT' octets='36844' target='http://www.rfc-editor.org/rfc/rfc5285.txt' />
</reference>


      <!-- NORM 11 -->


<reference anchor='RFC6904'>

<front>
<title>Encryption of Header Extensions in the Secure Real-time Transport Protocol (SRTP)</title>
<author initials='J.' surname='Lennox' fullname='J. Lennox'>
<organization /></author>
<date year='2013' month='April' />
<abstract>
<t>The Secure Real-time Transport Protocol (SRTP) provides authentication, but not encryption, of the headers of Real-time Transport Protocol (RTP) packets. However, RTP header extensions may carry sensitive information for which participants in multimedia sessions want confidentiality. This document provides a mechanism, extending the mechanisms of SRTP, to selectively encrypt RTP header extensions in SRTP.&lt;/t>&lt;t> This document updates RFC 3711, the Secure Real-time Transport Protocol specification, to require that all future SRTP encryption transforms specify how RTP header extensions are to be encrypted.</t></abstract></front>

<seriesInfo name='RFC' value='6904' />
<format type='TXT' octets='33486' target='http://www.rfc-editor.org/rfc/rfc6904.txt' />
</reference>


      <!-- NORM 12 -->


<reference anchor='I-D.ietf-rtcweb-rtp-usage'>
<front>
<title>Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</title>

<author initials='C' surname='Perkins' fullname='Colin Perkins'>
    <organization />
</author>

<author initials='M' surname='Westerlund' fullname='Magnus Westerlund'>
    <organization />
</author>

<author initials='J' surname='Ott' fullname='Joerg Ott'>
    <organization />
</author>

<date month='September' day='5' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) framework provides support for direct interactive rich communication using audio, video, text, collaboration, games, etc.  between two peers' web-browsers.  This memo describes the media transport aspects of the WebRTC framework. It specifies how the Real-time Transport Protocol (RTP) is used in the WebRTC context, and gives requirements for which RTP features, profiles, and extensions need to be supported.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-rtcweb-rtp-usage-09' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-rtcweb-rtp-usage-09.txt' />
</reference>


      <!-- NORM 13 -->


<reference anchor='I-D.ietf-mmusic-sdp-bundle-negotiation'>
<front>
<title>Multiplexing Negotiation Using Session Description Protocol (SDP) Port Numbers</title>

<author initials='C' surname='Holmberg' fullname='Christer Holmberg'>
    <organization />
</author>

<author initials='H' surname='Alvestrand' fullname='Harald Alvestrand'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='June' day='14' year='2013' />

<abstract><t>This specification defines a new SDP Grouping Framework extension, "BUNDLE", that can be used with the Session Description Protocol (SDP) Offer/Answer mechanism to negotiate the usage of bundled media, which refers to the usage of a single 5-tuple for media associated with multiple SDP media descriptions ("m=" lines).</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-sdp-bundle-negotiation-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-bundle-negotiation-04.txt' />
</reference>


      <!-- NORM 14 -->


<reference anchor='I-D.ietf-mmusic-msid'>
<front>
<title>Cross Session Stream Identification in the Session Description Protocol</title>

<author initials='H' surname='Alvestrand' fullname='Harald Alvestrand'>
    <organization />
</author>

<date month='August' day='13' year='2013' />

<abstract><t>This document specifies a grouping mechanism for RTP media streams that can be used to specify relations between media streams.  This mechanism is used to signal the association between the SDP concept of "m-line" and the WebRTC concept of "MediaStream" / "MediaStreamTrack" using SDP signaling.  This document is a work item of the MMUSIC WG, whose discussion list is mmusic@ietf.org.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-mmusic-msid-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-mmusic-msid-01.txt' />
</reference>


      <!-- NORM 15 -->

      <!-- NORM 16 -->

      <!-- NORM 17 -->

      <!-- NORM 18 -->

      <!-- NORM 19 -->

      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723"
                target="http://www.rfc-editor.org/rfc/rfc2119.txt" type="TXT" />

        <format octets="17491"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5777"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>

      <reference anchor="RFC3264">
        <front>
          <title>An Offer/Answer Model with Session Description Protocol
          (SDP)</title>

          <author fullname="J. Rosenberg" initials="J." surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="H. Schulzrinne" initials="H."
                  surname="Schulzrinne">
            <organization></organization>
          </author>

          <date month="June" year="2002" />
        </front>

        <seriesInfo name="RFC" value="3264" />

        <format octets="60854"
                target="http://www.rfc-editor.org/rfc/rfc3264.txt" type="TXT" />
      </reference>

      <reference anchor="RFC4566">
        <front>
          <title>SDP: Session Description Protocol</title>

          <author fullname="M. Handley" initials="M." surname="Handley">
            <organization></organization>
          </author>

          <author fullname="V. Jacobson" initials="V." surname="Jacobson">
            <organization></organization>
          </author>

          <author fullname="C. Perkins" initials="C." surname="Perkins">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4566" />

        <format octets="108820"
                target="http://www.rfc-editor.org/rfc/rfc4566.txt" type="TXT" />
      </reference>
    </references>

    <references title="Informative References">
      <!-- INFORM 1 -->



<reference anchor='RFC3556'>

<front>
<title>Session Description Protocol (SDP) Bandwidth Modifiers for RTP Control Protocol (RTCP) Bandwidth</title>
<author initials='S.' surname='Casner' fullname='S. Casner'>
<organization /></author>
<date year='2003' month='July' />
<abstract>
<t>This document defines an extension to the Session Description Protocol (SDP)
to specify two additional modifiers for the bandwidth attribute.  These
modifiers may be used to specify the bandwidth allowed for RTP Control Protocol
(RTCP) packets in a Real-time Transport Protocol (RTP)
session. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='3556' />
<format type='TXT' octets='15310' target='http://www.rfc-editor.org/rfc/rfc3556.txt' />
</reference>

<reference anchor='RFC5576'>

<front>
<title>Source-Specific Media Attributes in the Session Description Protocol (SDP)</title>
<author initials='J.' surname='Lennox' fullname='J. Lennox'>
<organization /></author>
<author initials='J.' surname='Ott' fullname='J. Ott'>
<organization /></author>
<author initials='T.' surname='Schierl' fullname='T. Schierl'>
<organization /></author>
<date year='2009' month='June' />
<abstract>
<t>The Session Description Protocol (SDP) provides mechanisms to describe
attributes of multimedia sessions and of individual media streams (e.g.,
Real-time Transport Protocol (RTP) sessions) within a multimedia session, but
does not provide any mechanism to describe individual media sources within a
media stream.  This document defines a mechanism to describe RTP media sources,
which are identified by their synchronization source (SSRC) identifiers, in SDP,
to associate attributes with these sources, and to express relationships among
sources.  It also defines several source-level attributes that can be used to
describe properties of media sources. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5576' />
<format type='TXT' octets='40454' target='http://www.rfc-editor.org/rfc/rfc5576.txt' />
</reference>

<reference anchor='RFC5506'>

<front>
<title>Support for Reduced-Size Real-Time Transport Control Protocol (RTCP):
Opportunities and Consequences</title>
<author initials='I.' surname='Johansson' fullname='I. Johansson'>
<organization /></author>
<author initials='M.' surname='Westerlund' fullname='M. Westerlund'>
<organization /></author>
<date year='2009' month='April' />
<abstract>
<t>This memo discusses benefits and issues that arise when allowing Real-time
Transport Protocol (RTCP) packets to be transmitted with reduced size.  The size
can be reduced if the rules on how to create compound packets outlined in RFC
3550 are removed or changed.  Based on that analysis, this memo defines certain
changes to the rules to allow feedback messages to be sent as Reduced-Size RTCP
packets under certain conditions when using the RTP/AVPF (Real-time Transport
Protocol / Audio-Visual Profile with Feedback) profile (RFC 4585).  This
document updates RFC 3550, RFC 3711, and RFC
4585. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='5506' />
<format type='TXT' octets='41011' target='http://www.rfc-editor.org/rfc/rfc5506.txt' />
</reference>


      <!-- INFORM 2 -->


      <!-- INFORM 3 -->


      <!-- INFORM 4 -->


<reference anchor='RFC3960'>

<front>
<title>Early Media and Ringing Tone Generation in the Session Initiation Protocol (SIP)</title>
<author initials='G.' surname='Camarillo' fullname='G. Camarillo'>
<organization /></author>
<author initials='H.' surname='Schulzrinne' fullname='H. Schulzrinne'>
<organization /></author>
<date year='2004' month='December' />
<abstract>
<t>This document describes how to manage early media in the Session Initiation
Protocol (SIP) using two models: the gateway model and the application server
model.  It also describes the inputs one needs to consider in defining local
policies for ringing tone generation.  This memo provides information for the
Internet community.</t></abstract></front>

<seriesInfo name='RFC' value='3960' />
<format type='TXT' octets='31692' target='http://www.rfc-editor.org/rfc/rfc3960.txt' />
</reference>


      <!-- INFORM 5 -->


<reference anchor='I-D.jesup-rtcweb-data-protocol'>
<front>
<title>WebRTC Data Channel Protocol</title>

<author initials='R' surname='Jesup' fullname='Randell Jesup'>
    <organization />
</author>

<author initials='S' surname='Loreto' fullname='Salvatore Loreto'>
    <organization />
</author>

<author initials='M' surname='Tuexen' fullname='Michael Tuexen'>
    <organization />
</author>

<date month='February' day='26' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) working group is charged to provide protocols to support for direct interactive rich communication using audio, video, and data between two peers' web- browsers.  This document specifies an actual (minor) protocol for how the JS-layer DataChannel objects provide the data channels between the peers.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-jesup-rtcweb-data-protocol-04' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-jesup-rtcweb-data-protocol-04.txt' />
</reference>
      <!-- INFORM 6 -->


<reference anchor='RFC4588'>

<front>
<title>RTP Retransmission Payload Format</title>
<author initials='J.' surname='Rey' fullname='J. Rey'>
<organization /></author>
<author initials='D.' surname='Leon' fullname='D. Leon'>
<organization /></author>
<author initials='A.' surname='Miyazaki' fullname='A. Miyazaki'>
<organization /></author>
<author initials='V.' surname='Varsa' fullname='V. Varsa'>
<organization /></author>
<author initials='R.' surname='Hakenberg' fullname='R. Hakenberg'>
<organization /></author>
<date year='2006' month='July' />
<abstract>
<t>RTP retransmission is an effective packet loss recovery technique for real-time applications with relaxed delay bounds.  This document describes an RTP payload format for performing retransmissions.  Retransmitted RTP packets are sent in a separate stream from the original RTP stream.  It is assumed that feedback from receivers to senders is available.  In particular, it is assumed that Real-time Transport Control Protocol (RTCP) feedback as defined in the extended RTP profile for RTCP-based feedback (denoted RTP/AVPF) is available in this memo. [STANDARDS-TRACK]</t></abstract></front>

<seriesInfo name='RFC' value='4588' />
<format type='TXT' octets='76630' target='http://www.rfc-editor.org/rfc/rfc4588.txt' />
</reference>


      <!-- INFORM 7 -->


<reference anchor='RFC3389'>

<front>
<title>Real-time Transport Protocol (RTP) Payload for Comfort Noise (CN)</title>
<author initials='R.' surname='Zopf' fullname='R. Zopf'>
<organization /></author>
<date year='2002' month='September' /></front>

<seriesInfo name='RFC' value='3389' />
<format type='TXT' octets='17018' target='http://www.rfc-editor.org/rfc/rfc3389.txt' />
</reference>


      <!-- INFORM 8 -->



<reference anchor='I-D.ivov-mmusic-trickle-ice'>
<front>
<title>Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</title>

<author initials='E' surname='Ivov' fullname='Emil Ivov'>
    <organization />
</author>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<author initials='J' surname='Uberti' fullname='Justin Uberti'>
    <organization />
</author>

<date month='March' day='11' year='2013' />

<abstract><t>This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that allows ICE agents to send and receive candidates incrementally rather than exchanging complete lists.  With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete.  The above mechanism is also referred to as "trickle ICE".</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ivov-mmusic-trickle-ice-01' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ivov-mmusic-trickle-ice-01.txt' />
</reference>



      <!-- INFORM 9 -->

      <!-- INFORM 10 -->

      <!-- INFORM 11 -->

      <!-- INFORM 12 -->

      <!-- INFORM 13 -->

      <!-- INFORM 14 -->

      <!-- INFORM 15 -->


      <reference anchor="I-D.jennings-rtcweb-signaling">
        <front>
          <title>RTCWeb Offer/Answer Protocol (ROAP)</title>

          <author fullname="Cullen Jennings" initials="C" surname="Jennings">
            <organization></organization>
          </author>

          <author fullname="Jonathan Rosenberg" initials="J"
                  surname="Rosenberg">
            <organization></organization>
          </author>

          <author fullname="Randell Jesup" initials="R" surname="Jesup">
            <organization></organization>
          </author>

          <date day="30" month="October" year="2011" />

          <abstract>
            <t>This document describes an protocol used to negotiate media
            between browsers or other compatible devices. This protocol
            provides the state machinery needed to implement the offer/answer
            model (RFC 3264), and defines the semantics and necessary
            attributes of messages that must be exchanged. The protocol uses
            an abstract transport in that it does not actually define how
            these messages are exchanged. Rather, such exchanges are handled
            through web-based transports like HTTP or WebSockets. The protocol
            focuses solely on media negotiation and does not handle call
            control, call processing, or other functions.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-jennings-rtcweb-signaling-01" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.txt"
                type="TXT" />

        <format target="http://www.ietf.org/internet-drafts/draft-jennings-rtcweb-signaling-01.pdf"
                type="PDF" />
      </reference>


      <!-- INFORM 16 -->


<reference anchor='I-D.nandakumar-rtcweb-sdp'>
<front>
<title>SDP for the WebRTC</title>

<author initials='S' surname='Nandakumar' fullname='Suhas Nandakumar'>
    <organization />
</author>

<author initials='C' surname='Jennings' fullname='Cullen Jennings'>
    <organization />
</author>

<date month='July' day='13' year='2013' />

<abstract><t>The Web Real-Time Communication (WebRTC) [WEBRTC] working group is charged to provide protocol support for direct interactive rich communication using audio,video and data between two peers' web browsers.  With in the WebRTC framework, Session Description protocol (SDP) [RFC4566] is used for negotiating session capabilities between the peers.  Such a negotiataion happens based on the SDP Offer/Answer exchange mechanism described in the RFC 3264 [RFC3264].  This document serves a introductory purpose in describing the role of SDP for the most common WebRTC use-cases.  This SDP examples provided in this document is still a work in progress, but aims to align closest to the evolving standards.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-nandakumar-rtcweb-sdp-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-nandakumar-rtcweb-sdp-02.txt' />
<format type='PDF'
        target='http://www.ietf.org/internet-drafts/draft-nandakumar-rtcweb-sdp-02.pdf' />
</reference>


      <!-- INFORM 17 -->
<reference anchor='RFC5763'>
<front>
<title>
Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security
Context Using Datagram Transport Layer Security (DTLS)
</title>
<author initials='J.' surname='Fischl' fullname='J. Fischl'>
<organization/>
</author>
<author initials='H.' surname='Tschofenig' fullname='H. Tschofenig'>
<organization/>
</author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'>
<organization/>
</author>
<date year='2010' month='May'/>
<abstract>
<t>
This document specifies how to use the Session Initiation Protocol (SIP) to
establish a Secure Real-time Transport Protocol (SRTP) security context using
the Datagram Transport Layer Security (DTLS) protocol. It describes a mechanism
of transporting a fingerprint attribute in the Session Description Protocol
(SDP) that identifies the key that will be presented during the DTLS handshake.
The key exchange travels along the media path as opposed to the signaling path.
The SIP Identity mechanism can be used to protect the integrity of the
fingerprint attribute from modification by intermediate proxies.
[STANDARDS-TRACK]
</t>
</abstract>
</front>
<seriesInfo name='RFC' value='5763'/>
<format type='TXT' octets='81546' target='http://www.rfc-editor.org/rfc/rfc5763.txt'/>
</reference>

      <reference anchor="RFC4568">
        <front>
          <title>Session Description Protocol (SDP) Security Descriptions for
          Media Streams</title>

          <author fullname="F. Andreasen" initials="F." surname="Andreasen">
            <organization></organization>
          </author>

          <author fullname="M. Baugher" initials="M." surname="Baugher">
            <organization></organization>
          </author>

          <author fullname="D. Wing" initials="D." surname="Wing">
            <organization></organization>
          </author>

          <date month="July" year="2006" />
        </front>

        <seriesInfo name="RFC" value="4568" />

        <format octets="107881"
                target="http://www.rfc-editor.org/rfc/rfc4568.txt" type="TXT" />
      </reference>

      <reference anchor="W3C.WD-webrtc-20111027"
                 target="http://www.w3.org/TR/2011/WD-webrtc-20111027">
        <front>
          <title>WebRTC 1.0: Real-time Communication Between Browsers</title>

          <author fullname="Adam Bergkvist" initials="A." surname="Bergkvist">
            <organization></organization>
          </author>

          <author fullname="Daniel C. Burnett" initials="D." surname="Burnett">
            <organization></organization>
          </author>

          <author fullname="Anant Narayanan" initials="A." surname="Narayanan">
            <organization></organization>
          </author>

          <author fullname="Cullen Jennings" initials="C." surname="Jennings">
            <organization></organization>
          </author>

          <date day="27" month="October" year="2011" />
        </front>

        <seriesInfo name="World Wide Web Consortium WD"
                    value="WD-webrtc-20111027" />

        <format target="http://www.w3.org/TR/2011/WD-webrtc-20111027"
                type="HTML" />
      </reference>
    </references>

    <section title="JSEP Implementation Examples">
      <section title="Example API Flows">
        <t>Below are several sample flows for the new PeerConnection and
        library APIs, demonstrating when the various APIs are called in
        different situations and with various transport protocols. For clarity
        and simplicity, the createOffer/createAnswer calls are assumed to be
        synchronous in these examples, whereas the actual APIs are async.</t>

        <section title="Call using ROAP">
          <t>This example demonstrates a ROAP call, without the use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   iceCallback(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  {"type":"OFFER", "sdp":offer }

// OFFER arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", msg.sdp);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  iceCallback(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(msg.sdp, null);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  {"type":"ANSWER","sdp":answer }

// ANSWER arrives at Offerer
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererJS->AnswererJS:  {"type":"OK" }
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using XMPP">
          <t>This example demonstrates an XMPP call, making use of trickle
          candidates. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              xmpp = createSessionInitiate(offer);
OffererJS->AnswererJS:  <jingle action="session-initiate"/>

OffererJS->OffererUA:   pc.startIce();
OffererUA->OffererJS:   onicecandidate(cand);
OffererJS:              createTransportInfo(cand);
OffererJS->AnswererJS:  <jingle action="transport-info"/>

// session-initiate arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseSessionInitiate(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);

// transport-infos arrive at Answerer
AnswererJS->AnswererUA: candidate = parseTransportInfo(xmpp);
AnswererJS->AnswererUA: pc.addIceCandidate(candidate);
AnswererUA->AnswererJS: onicecandidate(cand)
AnswererJS:             createTransportInfo(cand);
AnswererJS->OffererJS:  <jingle action="transport-info"/>

// transport-infos arrive at Offerer
OffererJS->OffererUA:   candidates = parseTransportInfo(xmpp);
OffererJS->OffererUA:   pc.addIceCandidate(candidates);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS:             xmpp = createSessionAccept(answer);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  <jingle action="session-accept"/>

// session-accept arrives at Offerer
OffererJS:              answer = parseSessionAccept(xmpp);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Adding video to a call, using XMPP">
          <t>This example demonstrates an XMPP call, where the XMPP
          content-add mechanism is used to add video media to an existing
          session. For simplicity, candidate exchange is not shown.</t>

          <t>Note that the offerer for the change to the session may be
          different than the original call offerer. <figure>
              <artwork><![CDATA[
// Offerer adds video stream
OffererJS->OffererUA:   pc.addStream(videoStream)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createContentAdd(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="content-add"/>

// content-add arrives at Answerer
AnswererJS:             offer = parseContentAdd(xmpp);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS:             xmpp = createContentAccept(answer);
AnswererJS->OffererJS:  <jingle action="content-accept"/>

// content-accept arrives at Offerer
OffererJS:              answer = parseContentAccept(xmpp);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Simultaneous add of video streams, using XMPP">
          <t>This example demonstrates an XMPP call, where new video sources
          are added at the same time to a call that already has video; since
          adding these sources only affects one side of the call, there is no
          conflict. The XMPP description-info mechanism is used to indicate
          the new sources to the remote side. <figure>
              <artwork><![CDATA[
// Offerer and "Answerer" add video streams at the same time
OffererJS->OffererUA:   pc.addStream(offererVideoStream2)
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS:              xmpp = createDescriptionInfo(offer);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS->AnswererJS:  <jingle action="description-info"/>

AnswererJS->AnswererUA: pc.addStream(answererVideoStream2)
AnswererJS->AnswererUA: offer = pc.createOffer(null);
AnswererJS:             xmpp = createDescriptionInfo(offer);
AnswererJS->AnswererUA: pc.setLocalDescription("offer", offer);
AnswererJS->OffererJS:  <jingle action="description-info"/>

// description-info arrives at "Answerer", and is acked
AnswererJS:             offer = parseDescriptionInfo(xmpp);
AnswererJS->OffererJS:  <iq type="result"/>  // ack

// description-info arrives at Offerer, and is acked
OffererJS:              offer = parseDescriptionInfo(xmpp);
OffererJS->AnswererJS:  <iq type="result"/>  // ack

// ack arrives at Offerer; remote offer is used as an answer
OffererJS->OffererUA:   pc.setRemoteDescription("answer", offer);

// ack arrives at "Answerer"; remote offer is used as an answer
AnswererJS->AnswererUA: pc.setRemoteDescription("answer", offer);
]]></artwork>
            </figure></t>
        </section>

        <section title="Call using SIP">
          <t>This example demonstrates a simple SIP call (e.g. where the
          client talks to a SIP proxy over WebSockets). <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// INVITE arrives at Answerer
AnswererJS->AnswererUA: pc = new PeerConnection();
AnswererJS:             offer = parseInvite(sip);
AnswererJS->AnswererUA: pc.setRemoteDescription("offer", offer);
AnswererUA->AnswererJS: onaddstream(remoteStream);
AnswererUA->OffererUA:  onicecandidate(candidate);

// Answerer accepts call
AnswererJS->AnswererUA: pc.addStream(localStream, null);
AnswererJS->AnswererUA: answer = pc.createAnswer(offer, null);
AnswererJS:             sip = createResponse(200, answer);
AnswererJS->AnswererUA: pc.setLocalDescription("answer", answer);
AnswererJS->OffererJS:  200 OK w/ SDP

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);
OffererJS->AnswererJS:  ACK

// ICE Completes (at Answerer)
AnswererUA->OffererUA:  Media

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling early media (e.g. 1-800-GO FEDEX), using SIP">
          <t>This example demonstrates how early media could be handled; for
          simplicity, only the offerer side of the call is shown. <figure>
              <artwork><![CDATA[
// Call is initiated toward Answerer
OffererJS->OffererUA:   pc = new PeerConnection();
OffererJS->OffererUA:   pc.addStream(localStream, null);
OffererUA->OffererJS:   onicecandidate(candidate);
OffererJS->OffererUA:   offer = pc.createOffer(null);
OffererJS->OffererUA:   pc.setLocalDescription("offer", offer);
OffererJS:              sip = createInvite(offer);
OffererJS->AnswererJS:  SIP INVITE w/ SDP

// 180 Ringing is received by offerer, w/ SDP
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("pranswer", answer);
OffererUA->OffererJS:   onaddstream(remoteStream);

// ICE Completes (at Offerer)
OffererUA->AnswererUA:  Media

// 200 OK arrives at Offerer
OffererJS:              answer = parseResponse(sip);
OffererJS->OffererUA:   pc.setRemoteDescription("answer", answer);
OffererJS->AnswererJS:  ACK
]]></artwork>
            </figure></t>
        </section>
      </section>
      <section title="Example Session Descriptions">
        <section title="createOffer">
            <t>This SDP shows a typical result from createOffer for a PeerConnection with a single audio MediaStreamTrack and a single video MediaStreamTrack.
                [TODO: candidates have already been gathered here. Update for trickle.] 
Note some lines have been broken into two lines for formatting reasons. </t>
            <figure><artwork>
v=0
o=- 4962303333179871722 1 IN IP4 0.0.0.0
s=-
t=0 0
a=group:BUNDLE audio video
m=audio 58503 RTP/SAVPF 111 0 8 126
c=IN IP4 10.0.0.11
a=rtcp:49634 IN IP4 10.0.0.11
a=candidate:946015839 1 udp 2113937151 10.0.0.11 58503 
            typ host generation 0
a=candidate:946015839 2 udp 2113937150 10.0.0.11 49634 
            typ host generation 0
a=ice-ufrag:ETEn1v9DoTMB9J4r
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=ice-options:trickle
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=fingerprint [TODO]
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
a=ssrc:1732846380 cname:EocUG1f0fcg/yvY7
a=msid:47017fee-b6c1-4162-929c-a25110252400 
       f83006c5-a0ff-4e0a-9ed9-d3e6747be7d9
[TODO: ssrc-group]
m=video 57918 RTP/SAVPF 100 116 117
c=IN IP4 10.0.0.11
a=rtcp:50936 IN IP4 10.0.0.11
a=candidate:946015839 1 udp 2113937151 10.0.0.11 57918 typ host 
            generation 0
a=candidate:946015839 2 udp 2113937150 10.0.0.11 50936 typ host 
            generation 0
a=ice-ufrag:ETEn1v9DoTMB9J4r
a=ice-pwd:OtSK0WpNtpUjkY4+86js7ZQl
a=ice-options:trickle
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=fingerprint [TODO]
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:1366781083 cname:EocUG1f0fcg/yvY7
a=msid:61317484-2ed4-49d7-9eb7-1414322a7aae 
       f30bdb4a-5db8-49b5-bcdc-e0c9a23172e0
[TODO: ssrc-group]
[TODO: rtx]

            </artwork></figure>
        </section>
        <section title="createAnswer">
        </section>
      </section>
    </section>

    <section title="Change log">
      <t>Changes in draft-04: <list style="symbols">
        <t>Filled in sections on createOffer and createAnswer.</t>
        <t>Added SDP examples.</t>
        <t>Fixed references.</t>
      </list>
      </t>
      <t>Changes in draft-03: <list style="symbols">
          <t>Added text describing relationship to W3C specification</t>
        </list></t>

      <t>Changes in draft-02: <list style="symbols">
          <!-- A -->

          <t>Converted from nroff</t>

          <!-- B -->

          <t>Removed comparisons to old approaches abandoned by the working
          group</t>

          <!-- C -->

          <t>Removed stuff that has moved to W3C specificaiton</t>

          <!-- D -->

          <t>Align SDP handling with W3C draft</t>

          <!-- E -->

          <t>Clarified section on forking.</t>

          <!-- F -->

          <!-- G -->

          <!-- H -->

          <!-- I -->

          <!-- J -->

          <!-- K -->

          <!-- L -->
        </list></t>

      <t>Changes in draft-01: <list style="symbols">
          <t>Added diagrams for architecture and state machine.</t>

          <t>Added sections on forking and rehydration.</t>

          <t>Clarified meaning of "pranswer" and "answer".</t>

          <t>Reworked how ICE restarts and media directions are
          controlled.</t>

          <t>Added list of parameters that can be changed in a
          description.</t>

          <t>Updated suggested API and examples to match latest thinking.</t>

          <t>Suggested API and examples have been moved to an appendix.</t>
        </list></t>

      <t>Changes in draft -00: <list style="symbols">
          <t>Migrated from draft-uberti-rtcweb-jsep-02.</t>
        </list></t>
    </section>
  </back>
</rfc>
